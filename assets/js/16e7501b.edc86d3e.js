"use strict";(self.webpackChunkcogment_doc=self.webpackChunkcogment_doc||[]).push([[175],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>_});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),_=r,u=c["".concat(s,".").concat(_)]||c[_]||m[_]||o;return n?a.createElement(u,i(i({ref:t},d),{},{components:n})):a.createElement(u,i({ref:t},d))}));function _(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6758:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={},i="Step 7: Add a player trained with Reinforcement Learning using DQN",l={unversionedId:"guide/tutorial/dqn-player",id:"guide/tutorial/dqn-player",title:"Step 7: Add a player trained with Reinforcement Learning using DQN",description:"This part of the tutorial follows step 5 and step 6, make sure you've gone through either one of those before starting this one. Alternatively the completed step 5 can be retrieved from the tutorial's repository.",source:"@site/docs/guide/tutorial/7-dqn-player.md",sourceDirName:"guide/tutorial",slug:"/guide/tutorial/dqn-player",permalink:"/docs/guide/tutorial/dqn-player",draft:!1,tags:[],version:"current",lastUpdatedAt:1668807327,formattedLastUpdatedAt:"Nov 18, 2022",sidebarPosition:7,frontMatter:{},sidebar:"docSidebar",previous:{title:"Step 6: Add a web client for the human player",permalink:"/docs/guide/tutorial/web-client"},next:{title:"Step 8: Improving  operational efficiency with a directory",permalink:"/docs/guide/tutorial/directory"}},s={},p=[{value:"Creating an actor service",id:"creating-an-actor-service",level:2},{value:"Playing against the heuristic player",id:"playing-against-the-heuristic-player",level:2},{value:"Implementing the Deep Q Network",id:"implementing-the-deep-q-network",level:2},{value:"Random exploration",id:"random-exploration",level:2},{value:"Replay buffer",id:"replay-buffer",level:2},{value:"Training!",id:"training",level:2}],d={toc:p};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"step-7-add-a-player-trained-with-reinforcement-learning-using-dqn"},"Step 7: Add a player trained with Reinforcement Learning using DQN"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This part of the tutorial follows ",(0,r.kt)("a",{parentName:"p",href:"/docs/guide/tutorial/human-player"},"step 5")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/guide/tutorial/web-client"},"step 6"),", make sure you've gone through either one of those before starting this one. Alternatively the completed step 5 can be retrieved from the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cogment/cogment-tutorial-rps"},"tutorial's repository"),".")),(0,r.kt)("p",null,"In this step of the tutorial, we will go over yet another actor implementation and this implementation will be learning from its experience. We will implement an RPS player using Reinforcement Learning (RL) and more precisely a ",(0,r.kt)("a",{parentName:"p",href:"https://arxiv.org/pdf/1312.5602.pdf"},"Deep Q Network"),", one of the foundational algorithms of modern RL."),(0,r.kt)("p",null,"While we will explain some aspects of RL and DQN along the way, we won't go into all the details. Interested readers can refer to ",(0,r.kt)("a",{parentName:"p",href:"http://incompleteideas.net/book/the-book-2nd.html"},'"Reinforcement Learning: An Introduction" by Richard S. Sutton and Andrew G. Barto')," or to the original Deep Q Network article linked above."),(0,r.kt)("h2",{id:"creating-an-actor-service"},"Creating an actor service"),(0,r.kt)("p",null,"Back in ",(0,r.kt)("a",{parentName:"p",href:"/docs/guide/tutorial/heuristic-player"},"step 4"),", we created a new implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"player")," actor class in the same service as the previous one. It was a sound choice for this implementation because it was small and didn't require additional dependencies. In some cases it makes more sense to create a fully separated service for a new actor implementation. This is what we will do here."),(0,r.kt)("p",null,"Start by copy/pasting the ",(0,r.kt)("inlineCode",{parentName:"p"},"random_agent")," folder and name the copy ",(0,r.kt)("inlineCode",{parentName:"p"},"dqn_agent"),". Let's then clean up ",(0,r.kt)("inlineCode",{parentName:"p"},"dqn_agent/main.py")," to keep only a single actor implentation and name it ",(0,r.kt)("inlineCode",{parentName:"p"},"dqn_agent"),". You should end up with something like the following."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import cog_settings\nfrom data_pb2 import PlayerAction\n\nimport cogment\n\nimport asyncio\nimport os\nimport random\n\nPORT = os.getenv(\'DQN_AGENT_PORT\')\n\nasync def dqn_agent(actor_session):\n    # ...\n\nasync def main():\n    print(f"Deep Q Learning agent service starting on port {PORT}...")\n\n    context = cogment.Context(cog_settings=cog_settings, user_id="rps")\n    context.register_actor(\n        impl=dqn_agent,\n        impl_name="dqn_agent",\n        actor_classes=[\n            "player",\n        ],\n    )\n\n    await context.serve_all_registered(cogment.ServedEndpoint(port=PORT), prometheus_port=0)\n\n\nif __name__ == "__main__":\n    asyncio.run(main())\n')),(0,r.kt)("p",null,"Since we have created a new service we need to update the ",(0,r.kt)("inlineCode",{parentName:"p"},"run.sh")," script and the ",(0,r.kt)("inlineCode",{parentName:"p"},".env")," file for everything to work properly."),(0,r.kt)("p",null,"Let's add the following environment variables to the ",(0,r.kt)("inlineCode",{parentName:"p"},".env")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"DQN_AGENT_HOST=localhost\nDQN_AGENT_PORT=9004\n")),(0,r.kt)("p",null,"In the ",(0,r.kt)("inlineCode",{parentName:"p"},"./run.sh")," script we will add two new commands to build and start the dqn agent service."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"function dqn_agent_build() {\n  _py_build dqn_agent\n}\n\nfunction dqn_agent_start() {\n  _py_start dqn_agent\n}\n")),(0,r.kt)("p",null,"Finally in this file, we will add the dqn agent build to the ",(0,r.kt)("inlineCode",{parentName:"p"},"build")," command and the dqn agent start to the ",(0,r.kt)("inlineCode",{parentName:"p"},"services_start")," command."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"function build() {\n  _run_sequence client_build environment_build random_agent_build dqn_agent_build\n}\n\nfunction services_start() {\n  _run_parallel orchestrator_start environment_start random_agent_start dqn_agent_start\n}\n")),(0,r.kt)("h2",{id:"playing-against-the-heuristic-player"},"Playing against the heuristic player"),(0,r.kt)("p",null,"We will train our new player against the ",(0,r.kt)("a",{parentName:"p",href:"/docs/guide/tutorial/heuristic-player"},"heuristic player")," we previously developed. We first need to update the trial config in ",(0,r.kt)("inlineCode",{parentName:"p"},"client/main.py"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"player_1")," will be our new actor implementation while ",(0,r.kt)("inlineCode",{parentName:"p"},"player_2")," will be the heuristic implementation. We also need to update ",(0,r.kt)("inlineCode",{parentName:"p"},"client/main.py")," to run a bunch of trials sequentially as one game won't be enough to learn anything."),(0,r.kt)("p",null,"We need to define the grpc endpoint for this new service"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"DQN_AGENT_ENDPOINT = f\"grpc://{os.getenv('DQN_AGENT_HOST')}:{os.getenv('DQN_AGENT_PORT')}\"\n")),(0,r.kt)("p",null,"Then let's update the ",(0,r.kt)("inlineCode",{parentName:"p"},"actor_1_params")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'actor_1_params = cogment.ActorParameters(\n    cog_settings,\n    name="player_1",\n    class_name="player",\n    endpoint=DQN_AGENT_ENDPOINT,\n    implementation="dqn_agent"\n)\n')),(0,r.kt)("p",null,"Then let's adapt the trial running code to run 1000 trials."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Listening for ended trials\nasync def await_trial(trial_id):\n    async for trial_info in controller.watch_trials(trial_state_filters=[cogment.TrialState.ENDED]):\n        if trial_info.trial_id == trial_id:\n            break\n\n# Start a trial campaign\nfor i in range(1000):\n    # Defining the trial id on the client side\n    trial_id=f"rps-training#{i}-{datetime.datetime.now().isoformat()}"\n\n    await_trial_task = asyncio.create_task(await_trial(trial_id))\n\n    # Start a new trial using the trial params we just created\n    trial_id = await controller.start_trial(trial_id_requested=trial_id, trial_params=trial_params)\n    print(f"Trial \'{trial_id}\' ongoing")\n\n    # Wait for the trial to end\n    await await_trial_task\n')),(0,r.kt)("p",null,"You can now ",(0,r.kt)("a",{parentName:"p",href:"/docs/guide/tutorial/bootstrap-and-data-structures#building-and-running-the-app"},"build and run")," the application. It should take a few minutes to run as it goes through the trial campaign."),(0,r.kt)("h2",{id:"implementing-the-deep-q-network"},"Implementing the Deep Q Network"),(0,r.kt)("p",null,"We have set everything up, we can now focus on implementing our DQN agent."),(0,r.kt)("p",null,"A Deep Q Network is a neural network taking an observation as input, and outputing the Q value for each of the actions in the action space. The Q Value is an estimation of the expected value of all the rewards if a given action is taken. The DQN agent action policy is therefore to take the action having the largest predicted Q Value. Let's start by implementing this part and we will then deal with training this model."),(0,r.kt)("p",null,"In the rest of this tutorial we will use ",(0,r.kt)("a",{parentName:"p",href:"https://www.tensorflow.org"},"Tensorflow and its Keras API")," for the model itself, as well as ",(0,r.kt)("a",{parentName:"p",href:"https://numpy.org"},"numpy")," for datastructures. Let's add Tensorflow (it will install numpy too) to ",(0,r.kt)("inlineCode",{parentName:"p"},"dqn_agent/requirements.txt")," and import both at the top of ",(0,r.kt)("inlineCode",{parentName:"p"},"dqn_agent/main.py"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"tensorflow~=2.3\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"import numpy as np\nimport tensorflow as tf\n")),(0,r.kt)("p",null,"Let's get into the meat of the matter by implementing a function to create our model. We are using ",(0,r.kt)("a",{parentName:"p",href:"https://www.tensorflow.org/guide/keras/functional"},"Keras functional API")," to create the following layers:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Two scalar inputs, the last moves of the player and the opponent."),(0,r.kt)("li",{parentName:"ol"},"Each input is ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/One-hot#Machine_learning_and_statistics"},"one-hot encoded")," to avoid assuming an unwanted ordering and quantitative relationship between the moves."),(0,r.kt)("li",{parentName:"ol"},"The two encoded inputs are concatenated to a single vector."),(0,r.kt)("li",{parentName:"ol"},"A dense non-linear hidden layer is added."),(0,r.kt)("li",{parentName:"ol"},"The output layer estimates the Q value for each move.")),(0,r.kt)("p",null,"Everything then gets wrapped up and returned."),(0,r.kt)("p",null,"This function is then used to create a global ",(0,r.kt)("inlineCode",{parentName:"p"},"_model")," that we will use in the actor implementation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'MOVES = [ROCK, PAPER, SCISSORS]\nNO_LAST_MOVE = len(MOVES)\nLAST_MOVES = [ROCK, PAPER, SCISSORS, NO_LAST_MOVE] # The first round of the game has no information on last move\nactions_count = len(MOVES)\n\ndef create_model():\n    # 1. Input layers\n    in_me_last_move = tf.keras.Input(name="obs_me_last_move", shape=(1))\n    in_them_last_move = tf.keras.Input(name="obs_them_last_move", shape=(1))\n    # 2. One hot encoding of the layers\n    one_hot_move = tf.keras.layers.experimental.preprocessing.CategoryEncoding(\n        name="one_hot_move",\n        num_tokens=len(LAST_MOVES),\n        output_mode="binary"\n    )\n    one_hot_me_last_move = one_hot_move(in_me_last_move)\n    one_hot_them_last_move = one_hot_move(in_them_last_move)\n    # 3. Concatenating the two inputs\n    concat_ins = tf.keras.layers.concatenate(\n        [one_hot_me_last_move, one_hot_them_last_move]\n    )\n    # 4. Dense hidden layer\n    hidden_layer = tf.keras.layers.Dense(24, activation="relu")(concat_ins)\n    # 5. Output\n    outs = tf.keras.layers.Dense(actions_count, activation="linear")(hidden_layer)\n    return tf.keras.Model(\n        inputs=[in_me_last_move, in_them_last_move], outputs=outs, name="rps_dqn_policy"\n    )\n\n_model = create_model()\n')),(0,r.kt)("p",null,"The other piece of the puzzle is implementing a small function that will convert our observations into inputs for the model we just created. As most of the encoding is handled by the model itself, it's fairly straightforward."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def model_ins_from_observations(observations):\n    return {\n        "obs_me_last_move": np.array([\n            [o.observation.me.last_move if o.observation.me.HasField("last_move") else NO_LAST_MOVE]\n            for o in observations\n        ]),\n        "obs_them_last_move": np.array([\n            [o.observation.them.last_move if o.observation.them.HasField("last_move") else NO_LAST_MOVE]\n            for o in observations\n        ]),\n    }\n')),(0,r.kt)("p",null,"Finally we can make it work together by replacing the random choice of action by the use of the model. At the moment the model will just use the random initialization weights so don't expect much!"),(0,r.kt)("p",null,"Here is how the event loop in the ",(0,r.kt)("inlineCode",{parentName:"p"},"dqn_agent")," function will need to be updated:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Use ",(0,r.kt)("inlineCode",{parentName:"li"},"model_ins_from_observations")," to compute the model inputs,"),(0,r.kt)("li",{parentName:"ol"},"Use the model in inference mode to compute the q value of each of the possible actions,"),(0,r.kt)("li",{parentName:"ol"},"Finally, do the action having the largest q value.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"if event.observation:\n  model_ins = model_ins_from_observations([event.observation])\n  if event.type == cogment.EventType.ACTIVE:\n    model_outs = _model(model_ins, training=False)\n    action = tf.math.argmax(model_outs[0]).numpy()\n    actor_session.do_action(PlayerAction(move=action))\n")),(0,r.kt)("p",null,"You can now ",(0,r.kt)("a",{parentName:"p",href:"/docs/guide/tutorial/bootstrap-and-data-structures#building-and-running-the-app"},"build and run")," the application. It should take a few minutes to run as it goes through the trial campaign."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"In this example we define ",(0,r.kt)("inlineCode",{parentName:"p"},"_model")," (and other variables in the following sections) as global mutable variables. It works in our case because the dqn agents are neither distributed nor multithreaded.")),(0,r.kt)("h2",{id:"random-exploration"},"Random exploration"),(0,r.kt)("p",null,"With the previous code, you might have noticed that the agent will play exactly the same action given the same set of observations, this is because the weights of the model are fixed. However, especially at the beginning of the training process we want the agent to ",(0,r.kt)("em",{parentName:"p"},"experience")," a variety of situations. We address this issue by introducing a decaying exploration rate ",(0,r.kt)("em",{parentName:"p"},"epsilon"),"."),(0,r.kt)("p",null,"First we will define the parameters for this epsilon value as global variables: its minimum value, its maximum and initial value and its decay per tick. We also define as a global variable the current value of epsilon. You can add the following after the imports in ",(0,r.kt)("inlineCode",{parentName:"p"},"dqn_agent/main.py"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"epsilon_min = 0.05\nepsilon_max = 1.0\nepsilon_decay_per_tick = (\n  epsilon_max - epsilon_min\n) / 1000.0  # Linearly reach the lowest exploration rate after 1000 ticks\n\n_epsilon = epsilon_max\n")),(0,r.kt)("p",null,"We then create a simple function we can use everytime an action needs to be taken to retrieve and update ",(0,r.kt)("inlineCode",{parentName:"p"},"_epsilon"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_and_update_epsilon():\n  global _epsilon\n  current_epsilon = _epsilon\n  _epsilon -= epsilon_decay_per_tick\n  _epsilon = max(_epsilon, epsilon_min)\n  return current_epsilon\n")),(0,r.kt)("p",null,"This function can then be used to occasionally do random actions, to facilitate the exploration. To do that, we need to slightly modify how the actions are computed and submitted."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"if event.type == cogment.EventType.ACTIVE:\n  if np.random.rand(1)[0] < get_and_update_epsilon():\n    # Take random action\n    action = np.random.choice(actions_count)\n  else:\n    model_outs = _model(model_ins, training=False)\n    action = tf.math.argmax(model_outs[0]).numpy()\n  actor_session.do_action(PlayerAction(move=action))\n")),(0,r.kt)("p",null,"You can now ",(0,r.kt)("a",{parentName:"p",href:"/docs/guide/tutorial/bootstrap-and-data-structures#building-and-running-the-app"},"build and run")," the application. Nothing should appear different at this stage."),(0,r.kt)("h2",{id:"replay-buffer"},"Replay buffer"),(0,r.kt)("p",null,"In our journey to train a model, the next stage is to build an experience replay buffer to collect actions/observations/rewards triples over the course of the trials. Once done, it'll be usable to train the model using this data."),(0,r.kt)("p",null,"We will start by creating the datastructure. We are using a column-oriented structure relying on ",(0,r.kt)("a",{parentName:"p",href:"https://numpy.org/doc/stable/reference/generated/numpy.array.html"},"numpy arrays")," as they interoperate easily with tensorflow and support the needed manipulation primitives. Each row is a ",(0,r.kt)("strong",{parentName:"p"},"sample")," corresponding to one tick: the received observation and reward, the selected action as well as the next tick's received observation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def create_replay_buffer():\n  return {\n    "obs_me_last_move": np.array([]),\n    "obs_them_last_move": np.array([]),\n    "action": np.array([]),\n    "reward": np.array([]),\n    "next_obs_me_last_move": np.array([]),\n    "next_obs_them_last_move": np.array([]),\n  }\n\n_rb = create_replay_buffer()\n')),(0,r.kt)("p",null,"During each trial the agent will collect its data points in a ",(0,r.kt)("em",{parentName:"p"},"trial"),' replay buffer then append it to the global one. To achieve that we will first create the function in charge of the appending then collect data during the trial and call the "append" function.'),(0,r.kt)("p",null,"The following function will take a ",(0,r.kt)("em",{parentName:"p"},"trial")," replay buffer and append it to the global ",(0,r.kt)("inlineCode",{parentName:"p"},"_rb"),". To avoid memory overflow the replay buffer size is capped."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'_collected_samples_count = 0\nmax_replay_buffer_size = 100000\n\ndef append_trial_replay_buffer(trial_rb):\n  global _rb\n  global _collected_samples_count\n\n  trial_rb_size = len(trial_rb["obs_me_last_move"])\n\n  for key in _rb.keys():\n    # Append the trial data to the current vector\n    _rb[key] = np.append(_rb[key], trial_rb[key])\n    # Enforce the size limit by discarding older data\n    if len(_rb[key]) > max_replay_buffer_size:\n        _rb[key] = _rb[key][-max_replay_buffer_size:]\n\n  _collected_samples_count += trial_rb_size\n  rb_size = len(_rb["obs_me_last_move"])\n\n  # Sanity check, all vectors in the replay buffer should have the same size\n  for key in _rb.keys():\n    assert rb_size == len(_rb[key])\n\n  print(\n    f"{trial_rb_size} new samples stored after a trial, now having {rb_size} samples over a total of {_collected_samples_count} collected samples."\n  )\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"dqn_agent")," function can then be updated to collect received observations, rewards and sent actions. By default every action gets a ",(0,r.kt)("em",{parentName:"p"},"zero")," reward. When a reward for a specific tick is received, its value gets updated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'async def dqn_agent(actor_session):\n  actor_session.start()\n\n  trial_rb = create_replay_buffer()\n\n  async for event in actor_session.event_loop():\n    if event.observation:\n      model_ins = model_ins_from_observations([event.observation])\n      if event.type == cogment.EventType.ACTIVE:\n        # [...]\n        trial_rb["obs_me_last_move"] = np.append(\n            trial_rb["obs_me_last_move"], model_ins["obs_me_last_move"]\n        )\n        trial_rb["obs_them_last_move"] = np.append(\n            trial_rb["obs_them_last_move"], model_ins["obs_them_last_move"]\n        )\n        trial_rb["action"] = np.append(trial_rb["action"], [action])\n        trial_rb["reward"] = np.append(trial_rb["reward"], [0.0])\n      else:\n        trial_rb["obs_me_last_move"] = np.append(\n            trial_rb["obs_me_last_move"], model_ins["obs_me_last_move"]\n        )\n        trial_rb["obs_them_last_move"] = np.append(\n            trial_rb["obs_them_last_move"], model_ins["obs_them_last_move"]\n        )\n    for reward in event.rewards:\n      trial_rb["reward"][reward.tick_id] = reward.value\n\n  # Shifting the observations to get the next observations\n  trial_rb["next_obs_me_last_move"] = trial_rb["obs_me_last_move"][1:]\n  trial_rb["next_obs_them_last_move"] = trial_rb["obs_them_last_move"][1:]\n  # Dropping the last row, as it only contains the last observations\n  trial_rb["obs_me_last_move"] = trial_rb["obs_me_last_move"][:-1]\n  trial_rb["obs_them_last_move"] = trial_rb["obs_them_last_move"][:-1]\n  append_trial_replay_buffer(trial_rb)\n')),(0,r.kt)("p",null,"You can now ",(0,r.kt)("a",{parentName:"p",href:"/docs/guide/tutorial/bootstrap-and-data-structures#building-and-running-the-app"},"build and run")," the application. The behavior should be the same but the log should confirm that data gets accumulated."),(0,r.kt)("h2",{id:"training"},"Training!"),(0,r.kt)("p",null,"Here we are, all the pieces are in place, we can implement the training proper. The function is a standard implementation of DQN and is decomposed in 4 steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Select a random batch of samples from the replay buffer"),(0,r.kt)("li",{parentName:"ol"},"Compute the target Q value for each sample from the received reward and the next observation using a previous version of the model."),(0,r.kt)("li",{parentName:"ol"},"(Re)compute the estimated Q value of each sample from the selected action and observation using the current version of the model."),(0,r.kt)("li",{parentName:"ol"},"Perform an optimization step of the model parameters trying to reduce the loss between the samples estimated and target q values.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'batch_size = 50  # Size of batch taken from replay buffer\ngamma = 0.99  # Discount factor for future rewards\noptimizer = tf.keras.optimizers.Adam(learning_rate=0.00025, clipnorm=1.0)\nloss_function = tf.keras.losses.Huber()\ntarget_model_update_interval = 1000\n\n_target_model = create_model()\n\ndef train():\n    global _model\n    global _target_model\n\n    rb_size = len(_rb["obs_me_last_move"])\n\n    if rb_size >= batch_size:\n        # Printing progress by looking at the wins ratio of the last trials\n        last_trials_wins_count = np.count_nonzero(_rb[\'reward\'][-batch_size:] == 1.0)\n        last_trials_losses_count = np.count_nonzero(_rb[\'reward\'][-batch_size:] == -1.0)\n        print(f"last_trials_wins_ratio={last_trials_wins_count /(last_trials_wins_count + last_trials_losses_count)}")\n\n        # Step 1 - Randomly select a batch\n        batch_indices = np.random.choice(range(rb_size), size=batch_size)\n        batch_rb = create_replay_buffer()\n        for key in batch_rb.keys():\n            batch_rb[key] = np.take(_rb[key], batch_indices)\n\n        # Step 2 - Compute target q values\n        ## Predict the expected reward for the next observation of each sample\n        ## Use the target model for stability\n        target_actions_q_values = _target_model(\n            {\n                "obs_me_last_move": batch_rb["next_obs_me_last_move"],\n                "obs_them_last_move": batch_rb["next_obs_them_last_move"],\n            }\n        )\n\n        ## target Q value = reward + discount factor * expected future reward\n        target_q_values = batch_rb["reward"] + gamma * tf.reduce_max(\n            target_actions_q_values, axis=1\n        )\n\n        # Step 3 - Compute estimated q values\n        ## Create masks of the taken actions to later select relevant q values\n        selected_actions_masks = tf.one_hot(batch_rb["action"], actions_count)\n\n        with tf.GradientTape() as tape:\n            ## Recompute q values for all the actions at each sample\n            estimated_actions_q_values = _model(\n                {\n                    "obs_me_last_move": batch_rb["obs_me_last_move"],\n                    "obs_them_last_move": batch_rb["obs_them_last_move"],\n                }\n            )\n\n            ## Apply the masks to get the Q value for taken actions\n            estimated_q_values = tf.reduce_sum(\n                tf.multiply(estimated_actions_q_values, selected_actions_masks), axis=1\n            )\n\n            ## Compute loss between the target Q values and the estimated Q values\n            loss = loss_function(target_q_values, estimated_q_values)\n            print(f"loss={loss.numpy()}")\n\n            ## Backpropagation!\n            grads = tape.gradient(loss, _model.trainable_variables)\n            optimizer.apply_gradients(zip(grads, _model.trainable_variables))\n\n        # Update the target model\n        if _collected_samples_count % target_model_update_interval == 0:\n            _target_model.set_weights(_model.get_weights())\n')),(0,r.kt)("p",null,"This function then needs to be called at the end of each trial after the call to ",(0,r.kt)("inlineCode",{parentName:"p"},"append_trial_replay_buffer"),"."),(0,r.kt)("p",null,"You can now ",(0,r.kt)("a",{parentName:"p",href:"/docs/guide/tutorial/bootstrap-and-data-structures#building-and-running-the-app"},"build and run")," the application. The dqn agent will start to learn and quickly prevail against the heuristic implementation. You can monitor the progress in the logs, the wins ratio should be close to 1 after ~500 trials."),(0,r.kt)("p",null,"This concludes the step 7 of the tutorial: you implemented your first trained actor implementation!"))}m.isMDXComponent=!0}}]);