"use strict";(self.webpackChunkcogment_doc=self.webpackChunkcogment_doc||[]).push([[769],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>h});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=p(a),h=i,k=c["".concat(s,".").concat(h)]||c[h]||m[h]||l;return a?n.createElement(k,r(r({ref:t},d),{},{components:a})):n.createElement(k,r({ref:t},d))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=a.length,r=new Array(l);r[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var p=2;p<l;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},5161:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var n=a(3117),i=(a(7294),a(3905));const l={sidebar_position:4,toc_min_heading_level:2,toc_max_heading_level:2},r="Python SDK",o={unversionedId:"reference/python",id:"reference/python",title:"Python SDK",description:"Repository Latest release",source:"@site/docs/reference/python.md",sourceDirName:"reference",slug:"/reference/python",permalink:"/docs/reference/python",draft:!1,tags:[],version:"current",lastUpdatedAt:1678462955,formattedLastUpdatedAt:"3/10/2023",sidebarPosition:4,frontMatter:{sidebar_position:4,toc_min_heading_level:2,toc_max_heading_level:2},sidebar:"docSidebar",previous:{title:"Launch",permalink:"/docs/reference/cli/launch"},next:{title:"Javascript SDK",permalink:"/docs/reference/javascript"}},s={},p=[{value:"Installation",id:"installation",level:2},{value:"General usage",id:"general-usage",level:2},{value:"<code>asyncio</code>",id:"asyncio",level:3},{value:"Logging",id:"logging",level:3},{value:"Trial Specifications",id:"trial-specifications",level:3},{value:"Trial Parameters",id:"trial-parameters",level:3},{value:"Compiling the spec file into cog_settings.py",id:"compiling-the-spec-file-into-cog_settingspy",level:3},{value:"Top-level import",id:"top-level-import",level:3},{value:"class cogment.Context",id:"class-cogmentcontext",level:2},{value:"<code>__init__(self, user_id, cog_settings, prometheus_registry=prometheus_client.core.REGISTRY, directory_endpoint=None, directory_auth_token=None)</code>",id:"__init__self-user_id-cog_settings-prometheus_registryprometheus_clientcoreregistry-directory_endpointnone-directory_auth_tokennone",level:3},{value:"<code>async serve_all_registered(self, served_endpoint, prometheus_port=None)</code>",id:"async-serve_all_registeredself-served_endpoint-prometheus_portnone",level:3},{value:"<code>async get_controller(self, endpoint=Endpoint())</code>",id:"async-get_controllerself-endpointendpoint",level:3},{value:"<code>async get_datastore(self, endpoint=Endpoint())</code>",id:"async-get_datastoreself-endpointendpoint",level:3},{value:"<code>async get_model_registry_v2(self, endpoint=Endpoint())</code>",id:"async-get_model_registry_v2self-endpointendpoint",level:3},{value:"<code>async join_trial(self, trial_id, endpoint=Endpoint(), impl_name=None, actor_name=None, actor_class=None)</code>",id:"async-join_trialself-trial_id-endpointendpoint-impl_namenone-actor_namenone-actor_classnone",level:3},{value:"<code>register_environment(self, impl, impl_name, properties={})</code>",id:"register_environmentself-impl-impl_name-properties",level:3},{value:"<code>register_actor(self, impl, impl_name, actor_classes=[], properties={})</code>",id:"register_actorself-impl-impl_name-actor_classes-properties",level:3},{value:"<code>register_pre_trial_hook(self, impl, properties={})</code>",id:"register_pre_trial_hookself-impl-properties",level:3},{value:"<code>register_datalog(self, impl, properties={})</code>",id:"register_datalogself-impl-properties",level:3},{value:"class Controller",id:"class-controller",level:2},{value:"<code>async start_trial(self, trial_config=None, trial_id_requested=None, trial_params=None)</code>",id:"async-start_trialself-trial_confignone-trial_id_requestednone-trial_paramsnone",level:3},{value:"<code>terminate_trial(self, trial_ids, hard=False)</code>",id:"terminate_trialself-trial_ids-hardfalse",level:3},{value:"<code>async get_trial_info(self, trial_ids)</code>",id:"async-get_trial_infoself-trial_ids",level:3},{value:"<code>async watch_trials(self, trial_state_filters=[])</code>",id:"async-watch_trialsself-trial_state_filters",level:3},{value:"<code>async get_actors(self, trial_id)</code>",id:"async-get_actorsself-trial_id",level:3},{value:"<code>async get_remote_versions(self)</code>",id:"async-get_remote_versionsself",level:3},{value:"class Datastore",id:"class-datastore",level:2},{value:"<code>async get_trials(self, ids)</code>",id:"async-get_trialsself-ids",level:3},{value:"<code>async all_trials(self, bundle_size=1, wait_for_trials=0)</code>",id:"async-all_trialsself-bundle_size1-wait_for_trials0",level:3},{value:"<code>async delete_trials(self, ids)</code>",id:"async-delete_trialsself-ids",level:3},{value:"<code>async all_samples(self, trial_infos, actor_names=[], actor_classes=[], actor_implementations=[], fields=[])</code>",id:"async-all_samplesself-trial_infos-actor_names-actor_classes-actor_implementations-fields",level:3},{value:"class ModelRegistry",id:"class-modelregistry",level:2},{value:"<code>async store_model(self, name, model, iteration_properties=None)</code>",id:"async-store_modelself-name-model-iteration_propertiesnone",level:3},{value:"<code>async publish_model(self, name, model, iteration_properties=None)</code>",id:"async-publish_modelself-name-model-iteration_propertiesnone",level:3},{value:"<code>async retrieve_model(self, name, iteration=-1)</code>",id:"async-retrieve_modelself-name-iteration-1",level:3},{value:"<code>async remove_model(self, name)</code>",id:"async-remove_modelself-name",level:3},{value:"<code>async list_models(self)</code>",id:"async-list_modelsself",level:3},{value:"<code>async list_iterations(self, model_name)</code>",id:"async-list_iterationsself-model_name",level:3},{value:"<code>async get_iteration_info(self, name, iteration)</code>",id:"async-get_iteration_infoself-name-iteration",level:3},{value:"<code>async update_model_info(self, name, properties)</code>",id:"async-update_model_infoself-name-properties",level:3},{value:"<code>async get_model_info(self, name)</code>",id:"async-get_model_infoself-name",level:3},{value:"<code>async iteration_updates(self, model_name)</code>",id:"async-iteration_updatesself-model_name",level:3},{value:"<code>async track_latest_model(self, name, deserialize_func=None, initial_wait=0)</code>",id:"async-track_latest_modelself-name-deserialize_funcnone-initial_wait0",level:3},{value:"class Session",id:"class-session",level:2},{value:"<code>get_trial_id(self)</code>",id:"get_trial_idself",level:3},{value:"<code>get_tick_id(self)</code>",id:"get_tick_idself",level:3},{value:"<code>is_trial_over(self)</code>",id:"is_trial_overself",level:3},{value:"<code>sending_done(self)</code>",id:"sending_doneself",level:3},{value:"<code>add_reward(self, value, confidence, to, tick_id=-1, user_data=None)</code>",id:"add_rewardself-value-confidence-to-tick_id-1-user_datanone",level:3},{value:"class EnvironmentSession(Session)",id:"class-environmentsessionsession",level:2},{value:"<code>start(self, observations = None, auto_done_sending=True)</code>",id:"startself-observations--none-auto_done_sendingtrue",level:3},{value:"<code>async all_events(self)</code>",id:"async-all_eventsself",level:3},{value:"<code>produce_observations(self, observations)</code>",id:"produce_observationsself-observations",level:3},{value:"<code>end(self, final_observations)</code>",id:"endself-final_observations",level:3},{value:"<code>get_active_actors(self)</code>",id:"get_active_actorsself",level:3},{value:"<code>send_message(self, payload, to)</code>",id:"send_messageself-payload-to",level:3},{value:"class ActorSession(Session)",id:"class-actorsessionsession",level:2},{value:"<code>start(self, auto_done_sending=True)</code>",id:"startself-auto_done_sendingtrue",level:3},{value:"<code>async all_events(self)</code>",id:"async-all_eventsself-1",level:3},{value:"<code>do_action(self, action)</code>",id:"do_actionself-action",level:3},{value:"<code>send_message(self, payload, to)</code>",id:"send_messageself-payload-to-1",level:3},{value:"class PrehookSession",id:"class-prehooksession",level:2},{value:"<code>get_trial_id(self)</code>",id:"get_trial_idself-1",level:3},{value:"<code>get_user_id(self)</code>",id:"get_user_idself",level:3},{value:"class DatalogSession",id:"class-datalogsession",level:2},{value:"<code>start(self)</code>",id:"startself",level:3},{value:"<code>all_samples(self)</code>",id:"all_samplesself",level:3},{value:"class cogment.Endpoint",id:"class-cogmentendpoint",level:2},{value:"<code>__init__(self, url=&quot;cogment://discover&quot;)</code>",id:"__init__self-urlcogmentdiscover",level:3},{value:"class cogment.ServedEndpoint",id:"class-cogmentservedendpoint",level:2},{value:"<code>__init__(self, port)</code>",id:"__init__self-port",level:3},{value:"class cogment.TrialState(enum.Enum)",id:"class-cogmenttrialstateenumenum",level:2},{value:"class TrialInfo",id:"class-trialinfo",level:2},{value:"class ActorInfo",id:"class-actorinfo",level:2},{value:"class RecvEvent",id:"class-recvevent",level:2},{value:"class cogment.EventType(enum.Enum)",id:"class-cogmenteventtypeenumenum",level:3},{value:"class RecvObservation",id:"class-recvobservation",level:2},{value:"class cogment.ActorStatus(enum.Enum)",id:"class-cogmentactorstatusenumenum",level:2},{value:"class RecvAction",id:"class-recvaction",level:2},{value:"class RecvMessage",id:"class-recvmessage",level:2},{value:"class RecvReward",id:"class-recvreward",level:2},{value:"<code>get_nb_sources(self)</code>",id:"get_nb_sourcesself",level:3},{value:"<code>all_sources(self)</code>",id:"all_sourcesself",level:3},{value:"class RecvRewardSource",id:"class-recvrewardsource",level:2},{value:"class cogment.TrialParameters",id:"class-cogmenttrialparameters",level:2},{value:"<code>__init__(self, cog_settings, **kwargs)</code>",id:"__init__self-cog_settings-kwargs",level:3},{value:"<code>get_serialization_type(self)</code>",id:"get_serialization_typeself",level:3},{value:"<code>serialize(self)</code>",id:"serializeself",level:3},{value:"<code>deserialize(self, raw_string, type=None)</code>",id:"deserializeself-raw_string-typenone",level:3},{value:"class cogment.ActorParameters",id:"class-cogmentactorparameters",level:2},{value:"<code>__init__(self, cog_settings, class_name, **kwargs)</code>",id:"__init__self-cog_settings-class_name-kwargs",level:3},{value:"class cogment.LogSample",id:"class-cogmentlogsample",level:2},{value:"<code>__init__(self, params)</code>",id:"__init__self-params",level:3},{value:"<code>get_serialization_type(self)</code>",id:"get_serialization_typeself-1",level:3},{value:"<code>serialize(self)</code>",id:"serializeself-1",level:3},{value:"<code>deserialize(self, raw_string)</code>",id:"deserializeself-raw_string",level:3},{value:"<code>all_actor_names(self)</code>",id:"all_actor_namesself",level:3},{value:"<code>get_action(self, actor)</code>",id:"get_actionself-actor",level:3},{value:"<code>get_observation(self, actor)</code>",id:"get_observationself-actor",level:3},{value:"<code>all_rewards(self)</code>",id:"all_rewardsself",level:3},{value:"<code>all_messages(self)</code>",id:"all_messagesself",level:3},{value:"class ModelInfo",id:"class-modelinfo",level:2},{value:"class ModelIterationInfo",id:"class-modeliterationinfo",level:2},{value:"class LatestModel",id:"class-latestmodel",level:2},{value:"<code>async get(self)</code>",id:"async-getself",level:3},{value:"<code>is_deserialized(self)</code>",id:"is_deserializedself",level:3},{value:"<code>is_available(self)</code>",id:"is_availableself",level:3},{value:"<code>async wait_for_available(self)</code>",id:"async-wait_for_availableself",level:3},{value:"<code>async wait_for_newer(self, iteration)</code>",id:"async-wait_for_newerself-iteration",level:3},{value:"class cogment.DatastoreFields(enum.Enum)",id:"class-cogmentdatastorefieldsenumenum",level:2},{value:"class DatastoreTrialInfo",id:"class-datastoretrialinfo",level:2},{value:"class DatastoreSample",id:"class-datastoresample",level:2},{value:"class DatastoreActorData",id:"class-datastoreactordata",level:2},{value:"<code>all_received_rewards(self)</code>",id:"all_received_rewardsself",level:3},{value:"<code>all_sent_rewards(self)</code>",id:"all_sent_rewardsself",level:3},{value:"<code>all_received_messages(self)</code>",id:"all_received_messagesself",level:3},{value:"<code>all_sent_messages(self)</code>",id:"all_sent_messagesself",level:3},{value:"class DatastoreReward",id:"class-datastorereward",level:2},{value:"class DatastoreMessage",id:"class-datastoremessage",level:2}],d={toc:p};function m(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"python-sdk"},"Python SDK"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/cogment/cogment-py-sdk"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/repository-cogment%2Fcogment--py--sdk-%235217b8?style=for-the-badge&logo=github",alt:"Repository"}))," ",(0,i.kt)("a",{parentName:"p",href:"https://pypi.org/project/cogment/"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/pypi/v/cogment?style=for-the-badge",alt:"Latest release"}))),(0,i.kt)("h2",{id:"installation"},"Installation"),(0,i.kt)("p",null,"The simplest way to install the python SDK is to just install it using pip: ",(0,i.kt)("inlineCode",{parentName:"p"},"pip install cogment"),"."),(0,i.kt)("p",null,"To install the generator (for ",(0,i.kt)("inlineCode",{parentName:"p"},"cog_settings.py"),") it is done similarly with pip: ",(0,i.kt)("inlineCode",{parentName:"p"},"pip install cogment[generate]"),". If both are needed, installing the generator will install the Python SDK."),(0,i.kt)("p",null,"The basic requirement is Python 3.7."),(0,i.kt)("h2",{id:"general-usage"},"General usage"),(0,i.kt)("h3",{id:"asyncio"},(0,i.kt)("inlineCode",{parentName:"h3"},"asyncio")),(0,i.kt)("p",null,"The Python SDK is designed to run concurrently and asynchronously using the Python ",(0,i.kt)("inlineCode",{parentName:"p"},"asyncio")," library. As such, it should be run in an ",(0,i.kt)("inlineCode",{parentName:"p"},"asyncio.Task"),"."),(0,i.kt)("p",null,"E.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"asyncio.run(MyMainFunction())\n")),(0,i.kt)("h3",{id:"logging"},"Logging"),(0,i.kt)("p",null,"The Python SDK uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"cogment.sdk")," logger, and the default log level is ",(0,i.kt)("inlineCode",{parentName:"p"},"INFO"),". E.g. to change the log level to ",(0,i.kt)("inlineCode",{parentName:"p"},"WARNING"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'import cogment\nimport logging\n\nlogging.getLogger("cogment.sdk").setLevel(logging.WARNING)\n')),(0,i.kt)("p",null,"Or set the environment variable ",(0,i.kt)("inlineCode",{parentName:"p"},"COGMENT_LOG_LEVEL")," to one of the values: ",(0,i.kt)("inlineCode",{parentName:"p"},"off"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"error"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"warning"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"info"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"debug"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"trace")," (which match the respective Python levels ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.CRITICAL"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.ERROR"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.WARNING"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.INFO"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.DEBUG"),").\nSince the Cogment Python SDK does not output any critical logs, the ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.CRITICAL")," level effectively turns logging off.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"trace")," level does not match a standard Python logging level and is mostly for internal use with a level lower than ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.DEBUG"),"."),(0,i.kt)("p",null,"The Cogment logger does not define a handler, and the handler management is left to the application (as is standard for a library in Python).\nThus the Python ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.lastResort")," handler will be used if no explicit handler is defined by the application (i.e. only warnings and errors will be output to stderr, with no formatting).\nThe application should enable a handler as required.\nE.g. for a default logging setup (including a stream handler):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import cogment\nimport logging\n\nlogging.basicConfig()\n")),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Calling any of the module level functions ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.log"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.debug"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.info"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.warning"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.error"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.critical")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.exception"),", will implicitly call ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.basicConfig"),".\nAnd calling ",(0,i.kt)("inlineCode",{parentName:"p"},"logging.basicConfig")," does nothing if there is a root handler already defined.\nSee Python documentation for ",(0,i.kt)("a",{parentName:"p",href:"https://docs.python.org/3/library/logging.html#logging.basicConfig"},"logging.basicConfig")))),(0,i.kt)("h3",{id:"trial-specifications"},"Trial Specifications"),(0,i.kt)("p",null,"The specifications of a trial type are contained in a ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/cogment-yaml"},"spec file")," and the imported files defined in the spec. This file is typically named ",(0,i.kt)("inlineCode",{parentName:"p"},"cogment.yaml"),"."),(0,i.kt)("p",null,"For example, an ",(0,i.kt)("a",{parentName:"p",href:"/docs/guide/core-concepts#actors"},"actor")," class is defined by its required observation space and action space."),(0,i.kt)("p",null,'These "spaces" are defined by using protobuf message types (from the imported files). ',(0,i.kt)("a",{parentName:"p",href:"/docs/guide/core-concepts#observations--actions"},"Observations and actions")," will simply be instances of the appropriate type."),(0,i.kt)("p",null,"Messages and feedback user data don't have a set type, they can be any type of protobuf message as long as the receiver can manage that type (i.e. the object received is an instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"google.protobuf.Any")," and the contained type should be checked against known types before handling). The type is determined by the provided message from the originator."),(0,i.kt)("h3",{id:"trial-parameters"},"Trial Parameters"),(0,i.kt)("p",null,"The trial ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/parameters"},"parameters")," can come from the Controller ",(0,i.kt)("inlineCode",{parentName:"p"},"start_trial")," command, from the default parameters provided to the Orchestrator on startup, or from the pre-trial hooks (themselves provided to the Orchestrator on startup)."),(0,i.kt)("p",null,"The parameters are mostly independent of the spec file (cogment.yaml), except that the active actors listed in the parameters must have their actor class match an actor class defined in the spec file."),(0,i.kt)("p",null,"Below, when we refer to the trial parameters, we mean the final parameters after any pre-trial hooks."),(0,i.kt)("h3",{id:"compiling-the-spec-file-into-cog_settingspy"},"Compiling the spec file into cog_settings.py"),(0,i.kt)("p",null,"In order to use the specifications within python scripts, the spec file needs to be compiled into python modules. This is done by the Python SDK generator (see ","[#installation]",")."),(0,i.kt)("p",null,"The generator is used this way:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ python3 -m cogment.generate --spec cogment.yaml --output ./cog_settings.py\n")),(0,i.kt)("p",null,"This will create a ",(0,i.kt)("inlineCode",{parentName:"p"},"cog_settings.py")," module in the current directory (",(0,i.kt)("inlineCode",{parentName:"p"},"--output ./"),"). The generator will also compile the imported ",(0,i.kt)("inlineCode",{parentName:"p"},"*.proto")," files into python modules that will be saved in the same location as the specified output file (",(0,i.kt)("inlineCode",{parentName:"p"},"cog_settings.py"),") and they will be named according to their proto names (",(0,i.kt)("inlineCode",{parentName:"p"},"*_pb2.py"),")."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"cog_settings.py")," Python module is required by all API entry points."),(0,i.kt)("h3",{id:"top-level-import"},"Top-level import"),(0,i.kt)("p",null,"The main module of the Cogment SDK is ",(0,i.kt)("inlineCode",{parentName:"p"},"cogment"),". But all cogment scripts need to start with a ",(0,i.kt)("inlineCode",{parentName:"p"},"cogment.Context"),", which also requires the generated module ",(0,i.kt)("inlineCode",{parentName:"p"},"cog_settings")," (project specific definitions created from the spec file)."),(0,i.kt)("p",null,"If one needs to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"cogment.TrialParameters")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"cogment.ActorParameters")," from scratch, the ",(0,i.kt)("inlineCode",{parentName:"p"},"cog_settings")," module is also required."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import cog_settings\nimport cogment\n")),(0,i.kt)("h2",{id:"class-cogmentcontext"},"class cogment.Context"),(0,i.kt)("p",null,"Class to setup and run all the different aspects of Cogment trials."),(0,i.kt)("h3",{id:"__init__self-user_id-cog_settings-prometheus_registryprometheus_clientcoreregistry-directory_endpointnone-directory_auth_tokennone"},(0,i.kt)("inlineCode",{parentName:"h3"},"__init__(self, user_id, cog_settings, prometheus_registry=prometheus_client.core.REGISTRY, directory_endpoint=None, directory_auth_token=None)")),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"user_id"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - Identifier for the user of this context."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cog_settings"),": ",(0,i.kt)("em",{parentName:"li"},"module")," - Settings module associated with trials that will be run (",(0,i.kt)("a",{parentName:"li",href:"#cog_settings.py"},"cog_settings")," namespace)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"prometheus_registry"),": ",(0,i.kt)("em",{parentName:"li"},"prometheus_client.core.CollectorRegistry instance")," - Prometheus registry that'll be used by the Cogment metrics in this context. Can be set to ",(0,i.kt)("inlineCode",{parentName:"li"},"None")," to completely deactivate them. The default value is Prometheus' default global registry."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"directory_endpoint"),": ",(0,i.kt)("em",{parentName:"li"},"Endpoint instance"),' - Grpc endpoint (i.e. starting with "grpc://") to access the directory. The directory will be used to inquire discovery endpoints, and to register the services for discovery. If no endpoint is provided, a check for the environment variable ',(0,i.kt)("inlineCode",{parentName:"li"},"COGMENT_DIRECTORY_ENDPOINT")," will be made and if it exists, it will be used as the URL of a basic endpoint."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"directory_auth_token"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - Authentication token for access to the directory. This token will be registered with the services, and must match registered tokens when inquiring the directory. If no token is provided, a check for the environment variable ",(0,i.kt)("inlineCode",{parentName:"li"},"COGMENT_DIRECTORY_AUTHENTICATION_TOKEN")," will be made and if it exists, it will be used as the token.")),(0,i.kt)("h3",{id:"async-serve_all_registeredself-served_endpoint-prometheus_portnone"},(0,i.kt)("inlineCode",{parentName:"h3"},"async serve_all_registered(self, served_endpoint, prometheus_port=None)")),(0,i.kt)("p",null,"Method to start and run the communication server for the registered components (environment, actor, prehook, datalog). This coroutine will end when all activity has stopped. If a directory is defined in the Context, then this method will also register the services in the defined directory."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"served_endpoint"),": ",(0,i.kt)("em",{parentName:"li"},"ServedEndpoint instance")," - Details of the connection for the served components."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"prometheus_port"),": ",(0,i.kt)("em",{parentName:"li"},"int")," - TCP/IP port number for Prometheus. Set to None to disable the Prometheus metrics server.")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"async-get_controllerself-endpointendpoint"},(0,i.kt)("inlineCode",{parentName:"h3"},"async get_controller(self, endpoint=Endpoint())")),(0,i.kt)("p",null,"Method to get a controller instance to manage trials (start, stop, inquire, etc)."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"endpoint"),": ",(0,i.kt)("em",{parentName:"li"},(0,i.kt)("a",{parentName:"em",href:"#class-cogmentendpoint"},"Endpoint")," instance")," - Details of the connection to the Orchestrator.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"Controller instance")," - An instance of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Controller")," class used to manage trials."),(0,i.kt)("h3",{id:"async-get_datastoreself-endpointendpoint"},(0,i.kt)("inlineCode",{parentName:"h3"},"async get_datastore(self, endpoint=Endpoint())")),(0,i.kt)("p",null,"Method to get a class instance to retrieve and manage data in a Datastore."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"endpoint"),": ",(0,i.kt)("em",{parentName:"li"},(0,i.kt)("a",{parentName:"em",href:"#class-cogmentendpoint"},"Endpoint")," instance")," - Details of the connection to the Datastore.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"Datastore instance")," - An instance of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Datastore")," class."),(0,i.kt)("h3",{id:"async-get_model_registry_v2self-endpointendpoint"},(0,i.kt)("inlineCode",{parentName:"h3"},"async get_model_registry_v2(self, endpoint=Endpoint())")),(0,i.kt)("p",null,"Method to get a class instance to store and retrieve models in a Model Registry"),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"endpoint"),": ",(0,i.kt)("em",{parentName:"li"},(0,i.kt)("a",{parentName:"em",href:"#class-cogmentendpoint"},"Endpoint")," instance")," - Details of the connection to the Model Registry.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"ModelRegistry instance")," - An instance of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ModelRegistry")," class."),(0,i.kt)("h3",{id:"async-join_trialself-trial_id-endpointendpoint-impl_namenone-actor_namenone-actor_classnone"},(0,i.kt)("inlineCode",{parentName:"h3"},"async join_trial(self, trial_id, endpoint=Endpoint(), impl_name=None, actor_name=None, actor_class=None)")),(0,i.kt)("p",null,"Method for an actor to asynchronously join an existing trial. This task will normally end after the user implementation has exited."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"trial_id"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The UUID of the trial to join."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"endpoint"),": ",(0,i.kt)("em",{parentName:"li"},(0,i.kt)("a",{parentName:"em",href:"#class-cogmentendpoint"},"Endpoint")," instance")," - Details of the connection to the Orchestrator."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"impl_name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - ",(0,i.kt)("strong",{parentName:"li"},"deprecated")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"actor_name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - Name of the actor joining the trial. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"actor_class")," will be used to find the actor to join. The name must match an active actor in the trial as found in the trial parameters in the sections ",(0,i.kt)("inlineCode",{parentName:"li"},"trial_params:actors:name")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"trial_params:actors:endpoint"),' set to "cogment://client".'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"actor_class"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The class of actor to join the trial. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"actor_name")," will be used to find the actor to join. The class must match an active actor in the trial as found in the trial parameters in the sections ",(0,i.kt)("inlineCode",{parentName:"li"},"trial_params:actors:actor_class")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"trial_params:actors:endpoint"),' set to "cogment://client".')),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"register_environmentself-impl-impl_name-properties"},(0,i.kt)("inlineCode",{parentName:"h3"},"register_environment(self, impl, impl_name, properties={})")),(0,i.kt)("p",null,"Method to register the asynchronous callback function that will run an environment for a trial."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"impl"),": ",(0,i.kt)("em",{parentName:"li"},"async function(EnvironmentSession instance)")," - Callback function to be registered."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"impl_name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - Name for the environment being run by the given callback function."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"properties"),": ",(0,i.kt)("em",{parentName:"li"},"dict{str:str}")," : Properties associated with the environment to be registered in the directory. These properties may be used for inquiries into the directory to find this environment.")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"register_actorself-impl-impl_name-actor_classes-properties"},(0,i.kt)("inlineCode",{parentName:"h3"},"register_actor(self, impl, impl_name, actor_classes=[], properties={})")),(0,i.kt)("p",null,"Method to register the asynchronous callback function that will run an actor for a trial."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"impl"),": ",(0,i.kt)("em",{parentName:"li"},"async func(ActorSession instance)")," - Callback function to be registered."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"impl_name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - Name for the actor implementation being run by the given callback function."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"actor_classes"),": ",(0,i.kt)("em",{parentName:"li"},"list","[str]")," - The actor class name(s) that can be run by the given callback function. The possible names are specified in the spec file under section ",(0,i.kt)("inlineCode",{parentName:"li"},"actor_classes:name"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"properties"),": ",(0,i.kt)("em",{parentName:"li"},"dict{str:str}")," : Properties associated with the actor to be registered in the directory. These properties may be used for inquiries into the directory to find this actor.")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"register_pre_trial_hookself-impl-properties"},(0,i.kt)("inlineCode",{parentName:"h3"},"register_pre_trial_hook(self, impl, properties={})")),(0,i.kt)("p",null,"Method to register an asynchronous callback function that will be called before a trial is started. Only one such function can be registered. But there may be multiple hook services for an Orchestrator. They are provided to the Orchestrator at startup. All hooks registered with the Orchestrator will be called in a pipeline fashion before each new trial."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"impl"),": ",(0,i.kt)("em",{parentName:"li"},"async func(PrehookSession instance)")," - Callback function to be registered. The ",(0,i.kt)("inlineCode",{parentName:"li"},"PrehookSession")," instance member data should be changed as needed for the new trial before returning from this function."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"properties"),": ",(0,i.kt)("em",{parentName:"li"},"dict{str:str}")," : Properties associated with the hook to be registered in the directory. These properties may be used for inquiries into the directory to find this hook.")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"register_datalogself-impl-properties"},(0,i.kt)("inlineCode",{parentName:"h3"},"register_datalog(self, impl, properties={})")),(0,i.kt)("p",null,"Method to register an asynchronous callback function that will be called for each trial to serve log requests. Only one such function can be registered. This service is addressed in the trial parameters in the ",(0,i.kt)("inlineCode",{parentName:"p"},"datalog")," section."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"impl"),": ",(0,i.kt)("em",{parentName:"li"},"async func(DatalogSession instance)")," - Callback function to be registered"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"properties"),": ",(0,i.kt)("em",{parentName:"li"},"dict{str:str}")," : Properties associated with the datalog to be registered in the directory. These properties may be used for inquiries into the directory to find this datalog.")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h2",{id:"class-controller"},"class Controller"),(0,i.kt)("p",null,"Class containing data and methods to control and manage trials."),(0,i.kt)("h3",{id:"async-start_trialself-trial_confignone-trial_id_requestednone-trial_paramsnone"},(0,i.kt)("inlineCode",{parentName:"h3"},"async start_trial(self, trial_config=None, trial_id_requested=None, trial_params=None)")),(0,i.kt)("p",null,"Method to start a new trial.\nThe config and parameter options are mutually exclusive."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"trial_config"),": ",(0,i.kt)("em",{parentName:"li"},"protobuf class instance")," - Configuration for the trial. The type is specified in the spec file under the section ",(0,i.kt)("inlineCode",{parentName:"li"},"trial:config_type"),". The config will be added to the default parameters (in the Orchestrator) and sent to the pre-trial hooks (if any). The pre-trial hooks will set the trial parameters according to the config. If there is no pre-trial hooks, the config is ignored and the default parameters are used. This cannot be provided with the ",(0,i.kt)("inlineCode",{parentName:"li"},"trial_params"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"trial_id_requested"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The trial identifier requested for the new trial. It must be unique among all active trials and a limited set of the latest ended trials (this list of trials can be retrieved with ",(0,i.kt)("inlineCode",{parentName:"li"},"get_trial_info")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"watch_trial"),"). If provided, the Orchestrator will try to use this trial_id, otherwise, a UUID will be created."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"trial_params"),": ",(0,i.kt)("em",{parentName:"li"},"TrialParameters instance")," - Fully defined parameters to start the new trial. This will be used as the trial parameters (I.e. the default parameters and pre-trial hooks are ignored). This cannot be provided with the ",(0,i.kt)("inlineCode",{parentName:"li"},"trial_config"),".")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"str")," - The newly started trial ID. An empty string if the trial was not started due to a non-unique requested ID."),(0,i.kt)("h3",{id:"terminate_trialself-trial_ids-hardfalse"},(0,i.kt)("inlineCode",{parentName:"h3"},"terminate_trial(self, trial_ids, hard=False)")),(0,i.kt)("p",null,"Method to request the end of a trial."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"trial_ids"),": ",(0,i.kt)("em",{parentName:"li"},"list","[str]")," - The trial ID(s) to request to terminate. There must be at least one ID."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hard"),": ",(0,i.kt)("em",{parentName:"li"},"bool")," - If ",(0,i.kt)("inlineCode",{parentName:"li"},"True"),", the termination will be forced and immediate, it will not wait for any action or observation. If ",(0,i.kt)("inlineCode",{parentName:"li"},"False"),", the trial will wait for the end of the next step, to end gracefully (i.e. wait for the next full set of actions and response observations), and the environment will have a chance to respond to an end request (an event of type ENDING).")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"async-get_trial_infoself-trial_ids"},(0,i.kt)("inlineCode",{parentName:"h3"},"async get_trial_info(self, trial_ids)")),(0,i.kt)("p",null,"Method to get information about a trial."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"trial_ids"),": ",(0,i.kt)("em",{parentName:"li"},"list","[str]")," - The trial ID(s) from which to request information. If no ID is provided, returns information about all trials. Note that ended trials may only appear for a short time in this list after they have ended.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"list","[TrialInfo instance]")," - List of trial information, one per trial. Can be empty if no trial matches."),(0,i.kt)("h3",{id:"async-watch_trialsself-trial_state_filters"},(0,i.kt)("inlineCode",{parentName:"h3"},"async watch_trials(self, trial_state_filters=[])")),(0,i.kt)("p",null,"Generator method to iterate, in real-time, through all trial states matching the filters. When called, it will first iterate over the current states matching the filters, for all trials. Afterwards, it will iterate in real-time over the matching states as they change."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"trial_state_filters"),": ",(0,i.kt)("em",{parentName:"li"},"list","[cogment.TrialState]")," - List of enum values from ",(0,i.kt)("inlineCode",{parentName:"li"},"cogment.TrialState")," for which we are interested in receiving state changes.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(TrialInfo instance)")," - A generator for the state changes that arrive. The ",(0,i.kt)("inlineCode",{parentName:"p"},"TrialInfo")," received here only contains the trial ID and the state."),(0,i.kt)("h3",{id:"async-get_actorsself-trial_id"},(0,i.kt)("inlineCode",{parentName:"h3"},"async get_actors(self, trial_id)")),(0,i.kt)("p",null,"Method to get the list of configured actors in a trial."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"trial_id"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The trial ID from which to request the list of actors.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"list","[ActorInfo instance]")," - List of actors configured in this trial."),(0,i.kt)("h3",{id:"async-get_remote_versionsself"},(0,i.kt)("inlineCode",{parentName:"h3"},"async get_remote_versions(self)")),(0,i.kt)("p",null,"Method to get the versions from the remote Orchestrator."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"dict")," - The key of the dictionary is the name of the component (",(0,i.kt)("em",{parentName:"p"},"str"),"), and the value is the version (",(0,i.kt)("em",{parentName:"p"},"str"),")."),(0,i.kt)("h2",{id:"class-datastore"},"class Datastore"),(0,i.kt)("p",null,"Class containing data and methods to retrieve historical (or real-time) trial samples from a Datastore.\nThis class can also be used to delete trials from a Datastore."),(0,i.kt)("h3",{id:"async-get_trialsself-ids"},(0,i.kt)("inlineCode",{parentName:"h3"},"async get_trials(self, ids)")),(0,i.kt)("p",null,"Method to get information about historical (or ongoing) trials in the Datastore.\nThis method is more efficient than ",(0,i.kt)("inlineCode",{parentName:"p"},"all_trials()"),", but can be problematic if too many trials are to be returned."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ids"),": ",(0,i.kt)("em",{parentName:"li"},"list","[str]")," - The trial IDs for which to request information. If no ID is provided (empty list), returns information about all trials in the Datastore.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"list","[DatastoreTrialInfo instance]")," - List of trial information, one per trial. Can be empty if no trial matches any of the provided trial IDs."),(0,i.kt)("h3",{id:"async-all_trialsself-bundle_size1-wait_for_trials0"},(0,i.kt)("inlineCode",{parentName:"h3"},"async all_trials(self, bundle_size=1, wait_for_trials=0)")),(0,i.kt)("p",null,"Generator method to iterate through all the trials in the Datastore."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"bundle_size"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - Number of trials to retrieve at a time from the Datastore. This may be increased to more efficiently inquire the Datastore at the price of increased memory use.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"wait_for_trials"),": ",(0,i.kt)("em",{parentName:"p"},"float")," - Number of seconds to wait for new trials (to reach bundle size). If 0, only the trials currently in the datastore will be returned."))),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(DatastoreTrialInfo instance)")," - A generator for the trials in the Datastore."),(0,i.kt)("h3",{id:"async-delete_trialsself-ids"},(0,i.kt)("inlineCode",{parentName:"h3"},"async delete_trials(self, ids)")),(0,i.kt)("p",null,"Method to delete historical trials recorded in the Datastore."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ids"),": ",(0,i.kt)("em",{parentName:"li"},"list","[str]")," - The trial IDs to remove from the Datastore.")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"async-all_samplesself-trial_infos-actor_names-actor_classes-actor_implementations-fields"},(0,i.kt)("inlineCode",{parentName:"h3"},"async all_samples(self, trial_infos, actor_names=[], actor_classes=[], actor_implementations=[], fields=[])")),(0,i.kt)("p",null,"Generator method to iterate through the samples from trials in the Datastore.\nThe samples can be historical (if the trial has ended) or real-time (if a trial is ongoing)."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"trial_infos"),": ",(0,i.kt)("em",{parentName:"p"},"list","[DatastoreTrialInfo]")," - Trials to request samples from. These should be the info instances received from ",(0,i.kt)("inlineCode",{parentName:"p"},"get_trials"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"actor_names"),": ",(0,i.kt)("em",{parentName:"p"},"list","[str]")," - Names of actors to consider including in the samples. If empty, all actors will be considered.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"actor_classes"),": ",(0,i.kt)("em",{parentName:"p"},"list","[str]")," - Actor classes to match for an actor to be included in the samples. If empty, actors in any class will be considered.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"actor_implementations"),": ",(0,i.kt)("em",{parentName:"p"},"list","[str]")," - Actor implementations to match for an actor to be included in the samples. If empty, actors with any implementation will be considered.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"fields"),": ",(0,i.kt)("em",{parentName:"p"},"list","[cogment.DatastoreFields]")," - Data fields to be filled in ",(0,i.kt)("inlineCode",{parentName:"p"},"DatastoreActorData")," (otherwise left empty). If the list is empty, all data will be filled in."))),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(DatastoreSample instance)")," - A generator for the samples from the Datastore."),(0,i.kt)("h2",{id:"class-modelregistry"},"class ModelRegistry"),(0,i.kt)("p",null,"Class containing data and methods to store and retrieve models from a ModelRegistry."),(0,i.kt)("h3",{id:"async-store_modelself-name-model-iteration_propertiesnone"},(0,i.kt)("inlineCode",{parentName:"h3"},"async store_model(self, name, model, iteration_properties=None)")),(0,i.kt)("p",null,"Method to publish and save the model to storage in the Model Registry.\nWhen stored, a model name will be available until explicitly deleted."),(0,i.kt)("p",null,"If the model name already exists, the model will be saved as a new iteration of the existing model name.\nIteration numbers start at 1 (the first model sent to the Model Registry) and increase by 1 for every new iteration.\nBut not all iterations may be in storage (see ",(0,i.kt)("a",{parentName:"p",href:"#async-publish_modelself-name-model-iteration_propertiesnone"},"publish_model"),")."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The model name to be stored."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"model"),": ",(0,i.kt)("em",{parentName:"li"},"bytes")," - The data representing the model."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"iteration_properties"),": ",(0,i.kt)("em",{parentName:"li"},"dict{str:str}")," - Custom information that is specific to this iteration and will be stored with it.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"ModelIterationInfo instance")," - The information about the newly stored model iteration."),(0,i.kt)("h3",{id:"async-publish_modelself-name-model-iteration_propertiesnone"},(0,i.kt)("inlineCode",{parentName:"h3"},"async publish_model(self, name, model, iteration_properties=None)")),(0,i.kt)("p",null,"Method to send a model to the Model Registry for the sole purpose of being published to other services.\nThis model will be transient and not saved in storage.\nIt will stay available in the Model Registry for a time, dependent on the Model Registry ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/cli/model-registry#cache_max_items"},"max_cache_item")," option, then be deleted automatically."),(0,i.kt)("p",null,"If the model name already exists, the model will be seen as a new iteration of the existing model name.\nIteration numbers start at 0 (the first model sent to the Model Registry) and increase by 1 for every new iteration."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The model name to be published."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"model"),": ",(0,i.kt)("em",{parentName:"li"},"bytes")," - The data representing the model."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"iteration_properties"),": ",(0,i.kt)("em",{parentName:"li"},"dict{str:str}")," - Custom information that is specific to this iteration.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"ModelIterationInfo instance")," - The information about the newly published model iteration."),(0,i.kt)("h3",{id:"async-retrieve_modelself-name-iteration-1"},(0,i.kt)("inlineCode",{parentName:"h3"},"async retrieve_model(self, name, iteration=-1)")),(0,i.kt)("p",null,"Method to retrieve the data of a specific model iteration from the ModelRegistry.\nTransient iterations may become unavailable at any time."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The model name to be retrieved."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"iteration"),": ",(0,i.kt)("em",{parentName:"li"},"int")," - The number of the model iteration to be retrieved. If -1, then the latest (most recent) iteration will be retrieved.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"bytes")," - The model data representing the specific iteration requested. ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if the iteration is not available (if ",(0,i.kt)("inlineCode",{parentName:"p"},"iteration")," = -1, it means the model has no iteration available)."),(0,i.kt)("h3",{id:"async-remove_modelself-name"},(0,i.kt)("inlineCode",{parentName:"h3"},"async remove_model(self, name)")),(0,i.kt)("p",null,"Method to delete a model (and all its stored and transient iterations) from the Model Registry."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The model name to be removed from the Model Registry.")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"async-list_modelsself"},(0,i.kt)("inlineCode",{parentName:"h3"},"async list_models(self)")),(0,i.kt)("p",null,"Method to retrieve the list of all models stored in the Model Registry."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"list","[ModelInfo instance]")," - List of model info for all models stored in the Model Registry."),(0,i.kt)("h3",{id:"async-list_iterationsself-model_name"},(0,i.kt)("inlineCode",{parentName:"h3"},"async list_iterations(self, model_name)")),(0,i.kt)("p",null,"Method to retrieve the list of all available iterations for a model in the Model Registry."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"model_name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The model name.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"list","[ModelIterationInfo instance]")," - List of iteration info for all available iterations of the model. This includes all stored iterations and all currently available transient iterations."),(0,i.kt)("h3",{id:"async-get_iteration_infoself-name-iteration"},(0,i.kt)("inlineCode",{parentName:"h3"},"async get_iteration_info(self, name, iteration)")),(0,i.kt)("p",null,"Method to retrieve information about a specific model iteration."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The model name."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"iteration"),": ",(0,i.kt)("em",{parentName:"li"},"int")," - The iteration number. If -1, then information about the latest (most recent) iteration will be retrieved.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"ModelIterationInfo instance")," - The information about the model iteration. ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if the iteration is not available (if ",(0,i.kt)("inlineCode",{parentName:"p"},"iteration")," = -1, it means the model has no iteration available)."),(0,i.kt)("h3",{id:"async-update_model_infoself-name-properties"},(0,i.kt)("inlineCode",{parentName:"h3"},"async update_model_info(self, name, properties)")),(0,i.kt)("p",null,"Method to store or update properties associated with the model name (not specific to any iteration)."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The model name."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"properties"),": ",(0,i.kt)("em",{parentName:"li"},"dict{str:str}")," - Custom information that will be stored with the model name, independently of any iteration. If the model name already has properties, they will be overwritten.")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"async-get_model_infoself-name"},(0,i.kt)("inlineCode",{parentName:"h3"},"async get_model_info(self, name)")),(0,i.kt)("p",null,"Method to retrieve information associated with the model name (not specific to any iteration)."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The model name.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"ModelInfo instance")," - Info associated with the model name, independent of any iteration. ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if the model is not found in the Model Registry."),(0,i.kt)("h3",{id:"async-iteration_updatesself-model_name"},(0,i.kt)("inlineCode",{parentName:"h3"},"async iteration_updates(self, model_name)")),(0,i.kt)("p",null,"Generator method to receive the information about the model iterations as they are stored or published."),(0,i.kt)("p",null,"Information about the latest iteration will be returned immediately, then the function will wait for new iterations to be stored or published to the Model Registry and return their information when they are made available."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"model_name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The model name for which to receive iteration information.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(ModelIterationInfo instance)")," - A generator for the model iteration information."),(0,i.kt)("h3",{id:"async-track_latest_modelself-name-deserialize_funcnone-initial_wait0"},(0,i.kt)("inlineCode",{parentName:"h3"},"async track_latest_model(self, name, deserialize_func=None, initial_wait=0)")),(0,i.kt)("p",null,"Method to start automatically tracking a specific model and make the latest iteration available seamlessly."),(0,i.kt)("p",null,"A background task will be started (running ",(0,i.kt)("inlineCode",{parentName:"p"},"iteration_updates"),") to track the latest model iteration and retrieve it automatically.\nMultiple calls for the same model will not duplicate the background task and will point to the same underlying model.\nThus if the model is changed by a caller, all callers will see the changes (unless and until a new model is retrieved from the Model Registry)."),(0,i.kt)("p",null,"Due to background processing and caching, this method is not thread safe and cannot be used by different async loops.\nIt is best used for simple cases. More complicated use-cases should explicitly use ",(0,i.kt)("inlineCode",{parentName:"p"},"iteration_updates"),"."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The model name to track."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"deserialize_func"),": ",(0,i.kt)("em",{parentName:"li"},"func(bytes)")," - Callback function to deserialize the model iteration from a ",(0,i.kt)("inlineCode",{parentName:"li"},"bytes")," string to a user defined object instance. This is called asynchronously in the background to deserialize the raw bytes from the Model Registry, and the user object is made available in ",(0,i.kt)("inlineCode",{parentName:"li"},"LatestModel"),". If not provided, the raw ",(0,i.kt)("inlineCode",{parentName:"li"},"bytes")," string from the Model Registry is made available in ",(0,i.kt)("inlineCode",{parentName:"li"},"LatestModel")," instead of a user object."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"initial_wait"),": ",(0,i.kt)("em",{parentName:"li"},"int")," - Number of seconds to wait for the model name to be available in the Model Registry. The method will return once the model name is available, or raise an exception if the model name was not available within the given time. The model name being available only means that it is registered in the Model Registry, not necessarily that it has iterations; i.e. the background task may wait more for iterations to be available.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"LatestModel instance")," -  An instance of the ",(0,i.kt)("inlineCode",{parentName:"p"},"LatestModel")," class."),(0,i.kt)("h2",{id:"class-session"},"class Session"),(0,i.kt)("p",null,"Abstract class that manages aspects of a trial. Contains data and methods common to all sessions ."),(0,i.kt)("h3",{id:"get_trial_idself"},(0,i.kt)("inlineCode",{parentName:"h3"},"get_trial_id(self)")),(0,i.kt)("p",null,"Method to get the UUID of the trial managed by this session."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"str")," - UUID of the trial."),(0,i.kt)("h3",{id:"get_tick_idself"},(0,i.kt)("inlineCode",{parentName:"h3"},"get_tick_id(self)")),(0,i.kt)("p",null,"Method to get the current tick id of the trial (i.e. time step)."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"int")," - The current tick id."),(0,i.kt)("h3",{id:"is_trial_overself"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_trial_over(self)")),(0,i.kt)("p",null,"Method to inquire if the current trial has ended."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"bool")," - True if the trial has ended, false otherwise."),(0,i.kt)("h3",{id:"sending_doneself"},(0,i.kt)("inlineCode",{parentName:"h3"},"sending_done(self)")),(0,i.kt)("p",null,"Method to notify the Orchestrator that all data for the trial, from this session, has been sent. This can be called only when the session is ending. When starting the session (see ",(0,i.kt)("inlineCode",{parentName:"p"},"EnvironmentSession")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ActorSession"),"), if the ",(0,i.kt)("inlineCode",{parentName:"p"},"auto_done_sending")," parameter is True, this method should not be called, and if the parameter is False, it MUST be called to end the trial properly."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"add_rewardself-value-confidence-to-tick_id-1-user_datanone"},(0,i.kt)("inlineCode",{parentName:"h3"},"add_reward(self, value, confidence, to, tick_id=-1, user_data=None)")),(0,i.kt)("p",null,"Method to send a reward to one or more actors."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"value"),": ",(0,i.kt)("em",{parentName:"li"},"float")," - Value of the reward. This will be aggregated with other rewards for the same target actor."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"confidence"),": ",(0,i.kt)("em",{parentName:"li"},"float")," - Weight of this reward value in determining the final aggregated reward. Should be > 0."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"to"),": ",(0,i.kt)("em",{parentName:"li"},"list","[str]"),' - Target(s) of reward. A list value could be the name of an actor in the trial. Or it could represent a set of actors; A set of actors can be represented with the wildcard character "',(0,i.kt)("inlineCode",{parentName:"li"},"*"),'" for all actors (of all classes), or "',(0,i.kt)("inlineCode",{parentName:"li"},"actor_class.*"),'" for all actors of a specific class (the ',(0,i.kt)("inlineCode",{parentName:"li"},"actor_class")," is the name of the class as specified in the spec file)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tick_id"),": ",(0,i.kt)("em",{parentName:"li"},"int"),' - The tick id (time step) for which the reward should be applied. If "-1", then the reward applies to the current time step.'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"user_data"),": ",(0,i.kt)("em",{parentName:"li"},"protobuf class instance")," - Extra user data to be sent with the reward. The class can be any protobuf class. It is the responsibility of the receiving actor to manage the class received (packed in a ",(0,i.kt)("inlineCode",{parentName:"li"},"google.protobuf.Any"),").")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h2",{id:"class-environmentsessionsession"},"class EnvironmentSession(Session)"),(0,i.kt)("p",null,"Class based on ",(0,i.kt)("inlineCode",{parentName:"p"},"Session"),", containing session data and methods necessary to run an environment for a trial. An instance of this class is passed as an argument to the environment callback function registered with ",(0,i.kt)("inlineCode",{parentName:"p"},"cogment.Context.register_environment"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"impl_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the implementation running this environment."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"config"),": ",(0,i.kt)("em",{parentName:"p"},"protobuf class instance")," - User configuration received for this environment instance. Can be ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if no configuration was provided. The type of the protobuf class is specified in the spec file in the section ",(0,i.kt)("inlineCode",{parentName:"p"},"environment:config_type"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the environment this instance represents."),(0,i.kt)("h3",{id:"startself-observations--none-auto_done_sendingtrue"},(0,i.kt)("inlineCode",{parentName:"h3"},"start(self, observations = None, auto_done_sending=True)")),(0,i.kt)("p",null,"Method to report that the environment is starting to run the trial. The method should be called before any other method in the session."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"observations"),": ",(0,i.kt)("em",{parentName:"p"},"list","[tuple(str, protobuf class instance)]")," - The initial observations from which the environment is starting the trial. This is the same as the parameter for ",(0,i.kt)("inlineCode",{parentName:"p"},"self.produce_observations"),". If not provided, then the first observation sent with ",(0,i.kt)("inlineCode",{parentName:"p"},"produce_observation")," will be used to initiate the trial (note that no actions will be received until the first observation is sent).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"auto_done_sending"),": ",(0,i.kt)("em",{parentName:"p"},"bool")," - Controls when to notify the Orchestrator that all data has been sent. If True, the session will automatically send the notification after ",(0,i.kt)("inlineCode",{parentName:"p"},"end")," is called. If False, the user MUST call ",(0,i.kt)("inlineCode",{parentName:"p"},"sending_done")," (after ",(0,i.kt)("inlineCode",{parentName:"p"},"end"),") to end the trial properly."))),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"async-all_eventsself"},(0,i.kt)("inlineCode",{parentName:"h3"},"async all_events(self)")),(0,i.kt)("p",null,"Generator method to iterate over all events (actions, messages) as they are received. This will block and wait for an event.\nWhen this generator exits, the callback function (registered with ",(0,i.kt)("inlineCode",{parentName:"p"},"register_environment"),') should return to end the trial cleanly.\nThe generator will exit for various reasons indicating the termination of the trial, a loss of communication with the orchestrator, or if the generator is sent "False" (in which case the callback function does not necessarily need to exit).'),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(RecvEvent instance)")," - A generator for the events that arrive. The ",(0,i.kt)("inlineCode",{parentName:"p"},"RecvEvent")," instances received from this generator will only contain actions or messages; no observations nor rewards. When receiving actions in the event, the ",(0,i.kt)("inlineCode",{parentName:"p"},"self.produce_observation"),' method is normally used to "reply" (or ',(0,i.kt)("inlineCode",{parentName:"p"},"self.end")," to end the trial)."),(0,i.kt)("h3",{id:"produce_observationsself-observations"},(0,i.kt)("inlineCode",{parentName:"h3"},"produce_observations(self, observations)")),(0,i.kt)("p",null,"Method to send observations to actors. If called after receiving an event of type ",(0,i.kt)("inlineCode",{parentName:"p"},"EventType.ENDING"),", the observation will be considered the final observation (equivalent to calling ",(0,i.kt)("inlineCode",{parentName:"p"},"end()"),")."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"observations"),": ",(0,i.kt)("em",{parentName:"li"},"list","[tuple(str, protobuf class instance)]"),' - The observations to send to actors. The string in the tuple is the name of the destination actor (or "',"*",'" for all actors). The name of the actors can be found in trial parameters under ',(0,i.kt)("inlineCode",{parentName:"li"},"trial_params:actors:name"),". The protobuf class is the Observation Space for that actor, found in the spec file in the corresponding section ",(0,i.kt)("inlineCode",{parentName:"li"},"actor_classes:observation:space"),".")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"endself-final_observations"},(0,i.kt)("inlineCode",{parentName:"h3"},"end(self, final_observations)")),(0,i.kt)("p",null,"Method to report the end of the environment. This will effectively end the trial. Message events can still arrive after this call."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"final_observations"),": ",(0,i.kt)("em",{parentName:"li"},"list","[tuple(str, protobuf class instance)]")," - The final observations to send to the actors. This is the same as the parameter for ",(0,i.kt)("inlineCode",{parentName:"li"},"self.produce_observations"),".")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"get_active_actorsself"},(0,i.kt)("inlineCode",{parentName:"h3"},"get_active_actors(self)")),(0,i.kt)("p",null,"Method to get the list of active actors in the trial."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"list","[ActorInfo instance]")," - List of active actors and classes involved in this trial."),(0,i.kt)("h3",{id:"send_messageself-payload-to"},(0,i.kt)("inlineCode",{parentName:"h3"},"send_message(self, payload, to)")),(0,i.kt)("p",null,"Method to send a message related to the current time step (tick id)."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"payload"),": ",(0,i.kt)("em",{parentName:"li"},"protobuf class instance")," - The message data to be sent. The class can be any protobuf class. It is the responsibility of the receiving environment to manage the class received (packed in a ",(0,i.kt)("inlineCode",{parentName:"li"},"google.protobuf.Any"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"to"),": ",(0,i.kt)("em",{parentName:"li"},"list","[str]"),' - Targets of feedback. Each value could be the name of an actor in the trial. Or it could represent a set of actors (with wildcards); A set of actors can be represented with the wildcard character "',(0,i.kt)("inlineCode",{parentName:"li"},"*"),'" for all actors (of all classes), or "',(0,i.kt)("inlineCode",{parentName:"li"},"actor_class.*"),'" for all actors of a specific class (the ',(0,i.kt)("inlineCode",{parentName:"li"},"actor_class")," must match one of the classes listed in the trial parameters). Note that the wildcard does not include the environment.")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h2",{id:"class-actorsessionsession"},"class ActorSession(Session)"),(0,i.kt)("p",null,"Class based on ",(0,i.kt)("inlineCode",{parentName:"p"},"Session"),", containing session/trial data and methods necessary to run an actor for a trial. An instance of this class is passed as argument to the actor callback function registered with ",(0,i.kt)("inlineCode",{parentName:"p"},"cogment.Context.register_actor"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"class_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the class of actor this instance represents. Specified in the spec file as ",(0,i.kt)("inlineCode",{parentName:"p"},"actor_classes:name"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"impl_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the implementation of the actor represented by this instance."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"config"),": ",(0,i.kt)("em",{parentName:"p"},"protobuf class instance")," - User configuration received for this actor instance. Can be ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," is no configuration was provided. The type of the protobuf class is specified in the spec file in the section ",(0,i.kt)("inlineCode",{parentName:"p"},"actor_classes:config_type"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the actor this instance represents."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"env_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the environment running the trial this actor is participating in (used to send messages to the environment)."),(0,i.kt)("h3",{id:"startself-auto_done_sendingtrue"},(0,i.kt)("inlineCode",{parentName:"h3"},"start(self, auto_done_sending=True)")),(0,i.kt)("p",null,"Method to start the actor. This method should be called before any other method in the session."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"auto_done_sending"),": ",(0,i.kt)("em",{parentName:"li"},"bool")," - Controls when to notify the Orchestrator that all data has been sent. If True, the session will automatically send the notification after receiving the last observation. If False, the user MUST call ",(0,i.kt)("inlineCode",{parentName:"li"},"sending_done")," to end the trial properly.")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"async-all_eventsself-1"},(0,i.kt)("inlineCode",{parentName:"h3"},"async all_events(self)")),(0,i.kt)("p",null,"Generator method to iterate over all events (observations, rewards, messages) as they are received. This will block and wait for an event.\nWhen this generator exits, the callback function (registered with ",(0,i.kt)("inlineCode",{parentName:"p"},"register_actor"),') should return to end the trial cleanly.\nThe generator will exit for various reasons indicating the end of the trial, a loss of communication with the orchestrator, or if the generator is sent "False".'),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(RecvEvent instance)")," - A generator for the events that arrive. The ",(0,i.kt)("inlineCode",{parentName:"p"},"RecvEvent")," instances received from this generator will not contain actions. When receiving an observation in the event, the ",(0,i.kt)("inlineCode",{parentName:"p"},"self.do_action"),' method is normally used to "reply" (if the event type is ',(0,i.kt)("inlineCode",{parentName:"p"},"EventType.ACTIVE"),")."),(0,i.kt)("h3",{id:"do_actionself-action"},(0,i.kt)("inlineCode",{parentName:"h3"},"do_action(self, action)")),(0,i.kt)("p",null,"Method to send actions to the environment."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"action"),": ",(0,i.kt)("em",{parentName:"li"},"protobuf class instance")," - An instance of the action space class specified in the corresponding section ",(0,i.kt)("inlineCode",{parentName:"li"},"actor_classes:action:space")," of the spec file. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", then no action space is sent (empty content) and the environment will receive a default initialized action space of the appropriate type.")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"send_messageself-payload-to-1"},(0,i.kt)("inlineCode",{parentName:"h3"},"send_message(self, payload, to)")),(0,i.kt)("p",null,"Method to send a message related to the current time step (tick id)."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"payload"),": ",(0,i.kt)("em",{parentName:"li"},"protobuf class instance")," - The message data to be sent. The class can be any protobuf class. It is the responsibility of the receiving actor to manage the class received (packed in a ",(0,i.kt)("inlineCode",{parentName:"li"},"google.protobuf.Any"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"to"),": ",(0,i.kt)("em",{parentName:"li"},"list","[str]")," - Targets of feedback. Each value could be the name of an actor in the trial, or the name of the environment (from ",(0,i.kt)("inlineCode",{parentName:"li"},"self.env_name"),'). Or it could represent a set of actors (with wildcards); A set of actors can be represented with the wildcard character "',(0,i.kt)("inlineCode",{parentName:"li"},"*"),'" for all actors (of all classes), or "',(0,i.kt)("inlineCode",{parentName:"li"},"actor_class.*"),'" for all actors of a specific class (the ',(0,i.kt)("inlineCode",{parentName:"li"},"actor_class")," must match one of the classes listed in the trial parameters). Note that the wildcard does not include the environment.")),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h2",{id:"class-prehooksession"},"class PrehookSession"),(0,i.kt)("p",null,"Class containing trial parameters to define the specifics of a trial. An instance of this class is passed as argument to the pre-trial hook callback function registered with ",(0,i.kt)("inlineCode",{parentName:"p"},"cogment.Context.register_pre_trial_hook"),". The first pre-trial hook to be called will receive the default parameters set in the Orchestrator, the following hooks will receive the parameters set by the preceding hooks."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"trial_parameters"),": ",(0,i.kt)("em",{parentName:"p"},"TrialParameters instance")," - Parameters for the trial. Initially received with parameters from the previous hook, or default parameters from the Orchestrator if it is the first hook. Changes to this instance will be forwarded to the next hook, or to the Orchestrator if it is the last hook."),(0,i.kt)("h3",{id:"get_trial_idself-1"},(0,i.kt)("inlineCode",{parentName:"h3"},"get_trial_id(self)")),(0,i.kt)("p",null,"Method to retrieve the ID of the trial."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"str")," - ID of the trial."),(0,i.kt)("h3",{id:"get_user_idself"},(0,i.kt)("inlineCode",{parentName:"h3"},"get_user_id(self)")),(0,i.kt)("p",null,"Method to retrieve the identifier of the user that started the trial."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"str")," - Identifier of the user that started the trial."),(0,i.kt)("h2",{id:"class-datalogsession"},"class DatalogSession"),(0,i.kt)("p",null,"Class containing session data and methods necessary to manage the logging of trial run data. An instance of this class is passed as an argument to the datalog callback function registered with ",(0,i.kt)("inlineCode",{parentName:"p"},"cogment.Context.register_datalog"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"trial_id"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - UUID of the trial managed by this instance."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"user_id"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Identifier of the user that started the trial."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"trial_parameters"),": ",(0,i.kt)("em",{parentName:"p"},"cogment.TrialParameters instance")," - Parameters of the trial."),(0,i.kt)("h3",{id:"startself"},(0,i.kt)("inlineCode",{parentName:"h3"},"start(self)")),(0,i.kt)("p",null,"Method to start receiving samples."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: None"),(0,i.kt)("h3",{id:"all_samplesself"},(0,i.kt)("inlineCode",{parentName:"h3"},"all_samples(self)")),(0,i.kt)("p",null,"Generator method to iterate over all samples as they are received (waiting for each in turn)."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(cogment.LogSample instance)")," - A generator for the samples received."),(0,i.kt)("h2",{id:"class-cogmentendpoint"},"class cogment.Endpoint"),(0,i.kt)("p",null,"Class enclosing the details for connecting to an Orchestrator."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"url"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - The URL where to connect to the Orchestrator."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"private_key"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - To use TLS for the connection, this must be set to the PEM-encoded private key."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"root_certificates"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - If using TLS for the connection (i.e. the ",(0,i.kt)("inlineCode",{parentName:"p"},"private_key")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),"), this can be set to the PEM-encoded root certificates. If not set and using TLS for the connection, the root certificates will be fetched from the system default location."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"certificate_chain"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - If using TLS for the connection, this can be set to the PEM-encoded certificate chain."),(0,i.kt)("h3",{id:"__init__self-urlcogmentdiscover"},(0,i.kt)("inlineCode",{parentName:"h3"},'__init__(self, url="cogment://discover")')),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"url"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The URL where to connect to the Orchestrator. By default this is a discovery URL that uses the Directory to find the corresponding endpoint.")),(0,i.kt)("h2",{id:"class-cogmentservedendpoint"},"class cogment.ServedEndpoint"),(0,i.kt)("p",null,"Class enclosing the details for connection from an Orchestrator."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"port"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - The TCP/IP port where the service will be awaiting the Orchestrator connection."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"private_key_certificate_chain_pairs"),": ",(0,i.kt)("em",{parentName:"p"},"list","[tuple(str, str)]")," - To use TLS for incoming connections, this must be set to a list of tuples of the form (PEM-encoded private key, PEM-encoded certificate chain)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"root_certificates"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - If using TLS for the connection (i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"private_key_certificate_chain_pairs")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),"), this should be set to PEM-encoded Orchestrator root certificates that the server will use to verify Orchestrator authentication."),(0,i.kt)("h3",{id:"__init__self-port"},(0,i.kt)("inlineCode",{parentName:"h3"},"__init__(self, port)")),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"port"),": ",(0,i.kt)("em",{parentName:"li"},"int")," - The TCP/IP port where the service will be awaiting the Orchestrator connection.")),(0,i.kt)("h2",{id:"class-cogmenttrialstateenumenum"},"class cogment.TrialState(enum.Enum)"),(0,i.kt)("p",null,"Enum representing the various states of trials."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"UNKNOWN: Should not be used."),(0,i.kt)("li",{parentName:"ul"},"INITIALIZING: The trial is in the process of starting."),(0,i.kt)("li",{parentName:"ul"},"PENDING: The trial is waiting for its final parameters, all the components to be ready, and the first observation."),(0,i.kt)("li",{parentName:"ul"},"RUNNING: The trial is running. "),(0,i.kt)("li",{parentName:"ul"},"TERMINATING: The trial is in the process of ending (either a request to end has been received or the last observation has been received)."),(0,i.kt)("li",{parentName:"ul"},"ENDED: The trial has ended. Only a set number of ended trials will be kept (configured in the Orchestrator).")),(0,i.kt)("p",null,"For further information on trial lifetime, check the ",(0,i.kt)("a",{parentName:"p",href:"/docs/guide/development-guide#trial-lifetime"},"dedicated section"),"."),(0,i.kt)("h2",{id:"class-trialinfo"},"class TrialInfo"),(0,i.kt)("p",null,"Class enclosing the details of a trial."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"trial_id"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - The trial ID to which the details pertain."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"properties"),": ",(0,i.kt)("em",{parentName:"p"},"dict{str:str}")," - User defined properties provided on trial start (see ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/parameters#trial-parameters"},"Trial Parameters"),")."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"state"),": ",(0,i.kt)("em",{parentName:"p"},"cogment.TrialState")," - The current state of the trial."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"env_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - The name of the environment running the trial."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tick_id"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - The time step that the information relates to. Only provided from a call to ",(0,i.kt)("inlineCode",{parentName:"p"},"get_trial_info"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"duration"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - The time (in nanoseconds) that the trial has run. Only provided from a call to ",(0,i.kt)("inlineCode",{parentName:"p"},"get_trial_info"),"."),(0,i.kt)("h2",{id:"class-actorinfo"},"class ActorInfo"),(0,i.kt)("p",null,"Class enclosing the details of an actor."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"actor_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - The name of the actor."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"actor_class_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - The name of the actor's class (as defined in the spec file)."),(0,i.kt)("h2",{id:"class-recvevent"},"class RecvEvent"),(0,i.kt)("p",null,"Class representing a received event (for environments and actors). It can contain any combination of data according to the receiver needs, or even be empty, but it will always have a type."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"type"),": ",(0,i.kt)("em",{parentName:"p"},"Enum EventType")," - Type of event the enclosed data represents."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"observation"),": ",(0,i.kt)("em",{parentName:"p"},"RecvObservation instance")," - Observation data. This can only be received by actors. ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if not present."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"actions"),": ",(0,i.kt)("em",{parentName:"p"},"list","[RecvAction instance]")," - Action data from actors. This can only be received by the environment. The list is empty if not present."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"rewards"),": ",(0,i.kt)("em",{parentName:"p"},"list","[RecvReward instance]")," - Reward values and data. This can only be received by actors. The list is empty if not present."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"messages"),": ",(0,i.kt)("em",{parentName:"p"},"list","[RecvMessage instance]")," - Message data. The list is empty if not present."),(0,i.kt)("h3",{id:"class-cogmenteventtypeenumenum"},"class cogment.EventType(enum.Enum)"),(0,i.kt)("p",null,"Enum representing the type of an event."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"EventType.NONE"),": Empty event. This kind of event should never be received.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"EventType.ACTIVE"),": Normal event from an active trial. Most events will be of this type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"EventType.ENDING"),": Events from a trial in the process of ending. Events of this type can contain the same data as ",(0,i.kt)("inlineCode",{parentName:"p"},"ACTIVE")," events. For the environment, the data received in ",(0,i.kt)("inlineCode",{parentName:"p"},"ENDING")," events are the last actions/messages, and the trial is awaiting a final observation. For the actors, the data received in ",(0,i.kt)("inlineCode",{parentName:"p"},"ENDING")," events are the final observations/rewards/messages, and no action can/need to be sent in response.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"EventType.FINAL"),": Final event for the trial. This does not contain data. The event loop will exit after this event is delivered. This event can be ignored if nothing needs to be done before exiting the loop."))),(0,i.kt)("p",null,"For further information on trial lifetime, check the ",(0,i.kt)("a",{parentName:"p",href:"/docs/guide/development-guide#trial-lifetime"},"dedicated section"),"."),(0,i.kt)("h2",{id:"class-recvobservation"},"class RecvObservation"),(0,i.kt)("p",null,"Class containing the details of an observation for an actor."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tick_id"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - The time step that the observation relates to."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"timestamp"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - Unix style Epoch timestamp in nanoseconds (time since 00:00:00 UTC Jan 1, 1970). Undefined if actor status is ",(0,i.kt)("inlineCode",{parentName:"p"},"ActorStatus.UNAVAILABLE"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"observation"),": ",(0,i.kt)("em",{parentName:"p"},"protobuf class instance")," - Observation received from the environment. The class of the observation is defined as observation space for the actor class. This is specified in section ",(0,i.kt)("inlineCode",{parentName:"p"},"actor_classes:observation:space")," in the spec file for the appropriate/receiving actor class. Undefined if actor status is ",(0,i.kt)("inlineCode",{parentName:"p"},"ActorStatus.UNAVAILABLE"),"."),(0,i.kt)("h2",{id:"class-cogmentactorstatusenumenum"},"class cogment.ActorStatus(enum.Enum)"),(0,i.kt)("p",null,"Enum representing the status of actors."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ActorStatus.UNKNOWN"),": This status should never be received.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ActorStatus.ACTIVE"),": The actor is active and responding to observations normally.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ActorStatus.UNAVAILABLE"),": The (optional) actor is unavailable (typically because of a time out).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ActorStatus.DEFAULT"),': The (optional) actor is acting by default (responding with the default action defined in the actor parameters). The environment will not see this kind of actor because a "default" actor looks active to the environment.'))),(0,i.kt)("h2",{id:"class-recvaction"},"class RecvAction"),(0,i.kt)("p",null,"Class containing the details of an action from an actor."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tick_id"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - The time step that the action relates to."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"actor_index"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - Index of the actor in the list of all trial actors (returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"Session.get_active_actors"),")."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"status"),": ",(0,i.kt)("em",{parentName:"p"},"ActorStatus instance")," - Indicate the status of the actor."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"timestamp"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - Unix style Epoch timestamp in nanoseconds (time since 00:00:00 UTC Jan 1, 1970) for the action. Undefined if ",(0,i.kt)("inlineCode",{parentName:"p"},"status")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"ActorStatus.ACTIVE"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"action"),": ",(0,i.kt)("em",{parentName:"p"},"protobuf class instance")," - Action from the actor which has index ",(0,i.kt)("inlineCode",{parentName:"p"},"actor_index")," in the trial. The class of the action is defined as action space for the specific actor in the section ",(0,i.kt)("inlineCode",{parentName:"p"},"actor_classes:action:space")," in the spec file for the appropriate actor class. Undefined if ",(0,i.kt)("inlineCode",{parentName:"p"},"status")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"ActorStatus.ACTIVE"),"."),(0,i.kt)("h2",{id:"class-recvmessage"},"class RecvMessage"),(0,i.kt)("p",null,"Class containing a message."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tick_id"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - The time step that the message relates to."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"receiver_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the receiver for the message (the name of an actor, or wildcard string)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"sender_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the sender of the message (the name of an actor, or the environment)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"payload"),": ",(0,i.kt)("em",{parentName:"p"},"google.protobuf.Any instance")," - Data for a received message. The class enclosed in ",(0,i.kt)("inlineCode",{parentName:"p"},"google.protobuf.Any")," is of the type set by the sender; It is the responsibility of the receiver to manage the data received (i.e. determine the type and unpack the data)."),(0,i.kt)("h2",{id:"class-recvreward"},"class RecvReward"),(0,i.kt)("p",null,"Class containing the details of a received reward."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tick_id"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - The tick id (time step) for which the reward should be applied."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"receiver_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the receiver for the reward (the name of an actor, or wildcard string)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"value"),": ",(0,i.kt)("em",{parentName:"p"},"float")," - Value of the reward (aggregated from the sources)"),(0,i.kt)("h3",{id:"get_nb_sourcesself"},(0,i.kt)("inlineCode",{parentName:"h3"},"get_nb_sources(self)")),(0,i.kt)("p",null,"Return the number of source rewards this reward is based upon."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"int")," - Number of sources."),(0,i.kt)("h3",{id:"all_sourcesself"},(0,i.kt)("inlineCode",{parentName:"h3"},"all_sources(self)")),(0,i.kt)("p",null,"Generator method to iterate over all sources making up this reward."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(RecvRewardSource instance)")," - A generator for the sources in the reward (simple rewards that make up this final/aggregate reward)."),(0,i.kt)("h2",{id:"class-recvrewardsource"},"class RecvRewardSource"),(0,i.kt)("p",null,"Class containing the details of a received single source reward."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"value"),": ",(0,i.kt)("em",{parentName:"p"},"float")," - Value of the reward from the sender."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"confidence"),": ",(0,i.kt)("em",{parentName:"p"},"float")," - Confidence level of this reward value."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"sender_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the sender of this reward (the name of an actor, or the environment)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"user_data"),": ",(0,i.kt)("em",{parentName:"p"},"google.protobuf.Any instance")," - Data for a user-specific reward format. Can be ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if no specific data was provided. The class enclosed in ",(0,i.kt)("inlineCode",{parentName:"p"},"google.protobuf.Any")," is of the type set by the sender; it is the responsibility of the receiver to manage the data received (i.e. determine the type and unpack the data)."),(0,i.kt)("h2",{id:"class-cogmenttrialparameters"},"class cogment.TrialParameters"),(0,i.kt)("p",null,"Class containing the parameters of the trial (see ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/parameters#trial-parameters"},"Trial Parameters"),")."),(0,i.kt)("p",null,"Any attribute can be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," to reset it to its default.\nSome attributes (",(0,i.kt)("inlineCode",{parentName:"p"},"config")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"environment_config"),") are immutable: changes to the instance received will not be reflected in ",(0,i.kt)("inlineCode",{parentName:"p"},"TrialParameters"),", the attribute must be set with a new instance to make changes. These attributes can also return ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if not set."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"config"),": ",(0,i.kt)("em",{parentName:"p"},"protobuf class instance")," - The type is specified in the spec file under the section ",(0,i.kt)("inlineCode",{parentName:"p"},"trial:config_type"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"properties"),": ",(0,i.kt)("em",{parentName:"p"},"dict{str:str}")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"max_steps"),": ",(0,i.kt)("em",{parentName:"p"},"int")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"max_inactivity"),": ",(0,i.kt)("em",{parentName:"p"},"int")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"nb_buffered_ticks"),": ",(0,i.kt)("em",{parentName:"p"},"int")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"datalog_endpoint"),": ",(0,i.kt)("em",{parentName:"p"},"str")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"datalog_exclude_fields"),": ",(0,i.kt)("em",{parentName:"p"},"tuple(str)")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"environment_config"),": ",(0,i.kt)("em",{parentName:"p"},"protobuf class instance")," - The type is specified in the spec file under the section ",(0,i.kt)("inlineCode",{parentName:"p"},"environment:config_type"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"environment_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"environment_endpoint"),": ",(0,i.kt)("em",{parentName:"p"},"str")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"environment_implementation"),": ",(0,i.kt)("em",{parentName:"p"},"str")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"actors"),": ",(0,i.kt)("em",{parentName:"p"},"list(cogment.ActorParameters)")," - The parameters for the actors. This is a list style object that implements the basic Python ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," functionality."),(0,i.kt)("h3",{id:"__init__self-cog_settings-kwargs"},(0,i.kt)("inlineCode",{parentName:"h3"},"__init__(self, cog_settings, **kwargs)")),(0,i.kt)("p",null,"Parameter:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cog_settings"),": ",(0,i.kt)("em",{parentName:"li"},"module")," - Settings module associated with trials that will be run (",(0,i.kt)("a",{parentName:"li",href:"#cog_settings.py"},"cog_settings")," namespace)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"**kwargs"),": Accepts any of the attributes as keyword to set their value on construction. E.g. ",(0,i.kt)("inlineCode",{parentName:"li"},'TrialParameters(settings, max_steps=1000, environment_name="level")'))),(0,i.kt)("h3",{id:"get_serialization_typeself"},(0,i.kt)("inlineCode",{parentName:"h3"},"get_serialization_type(self)")),(0,i.kt)("p",null,"Return the type of serial data produced by ",(0,i.kt)("inlineCode",{parentName:"p"},"serialize")," and accepted by ",(0,i.kt)("inlineCode",{parentName:"p"},"deserialize"),". The type represents an ID dependent on ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/grpc#trialparams"},"TrialParams")," defined in the low level gRPC API."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"int")," - The type of the serialization string data. This is the type of string that is returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"serialize"),", and the only type accepted by ",(0,i.kt)("inlineCode",{parentName:"p"},"deserialize"),"; it is undefined behavior to try to deserialize the wrong type of data. This value is strictly larger than 1."),(0,i.kt)("h3",{id:"serializeself"},(0,i.kt)("inlineCode",{parentName:"h3"},"serialize(self)")),(0,i.kt)("p",null,"Return a binary string equivalent of the parameters."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"str")," - Serialized parameters."),(0,i.kt)("h3",{id:"deserializeself-raw_string-typenone"},(0,i.kt)("inlineCode",{parentName:"h3"},"deserialize(self, raw_string, type=None)")),(0,i.kt)("p",null,"Takes a serialized parameter string and sets the ",(0,i.kt)("inlineCode",{parentName:"p"},"TrialParameters")," instance."),(0,i.kt)("p",null,"Parameter:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"raw_string"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - Binary string representing a serialized ",(0,i.kt)("inlineCode",{parentName:"li"},"TrialParameters")," of type ",(0,i.kt)("inlineCode",{parentName:"li"},"type"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"type"),": ",(0,i.kt)("em",{parentName:"li"},"int")," - Type of serial data in ",(0,i.kt)("inlineCode",{parentName:"li"},"raw_string")," (from ",(0,i.kt)("inlineCode",{parentName:"li"},"get_serialization")," of the source). If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", the current type is assumed (i.e. this instance type matches the source type).")),(0,i.kt)("h2",{id:"class-cogmentactorparameters"},"class cogment.ActorParameters"),(0,i.kt)("p",null,"Class containing the parameters for a particular actor (see ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/parameters#trial-parameters"},"Trial Parameters"),")."),(0,i.kt)("p",null,"Any attribute can be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," to reset it to its default.\nSome attributes (",(0,i.kt)("inlineCode",{parentName:"p"},"config"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"default_action"),") are immutable: changes to the instance received will not be reflected in ",(0,i.kt)("inlineCode",{parentName:"p"},"ActorParameters"),", the attribute must be set with a new instance to make changes. These attributes can also return ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if not set."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"config"),": ",(0,i.kt)("em",{parentName:"p"},"protobuf class instance")," - The type is specified in the spec file under the section ",(0,i.kt)("inlineCode",{parentName:"p"},"actor_classes:config_type")," for the specific actor class of the actor."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"class_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - This cannot be changed (it is a parameter of the constructor)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"name"),": ",(0,i.kt)("em",{parentName:"p"},"str")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"endpoint"),": ",(0,i.kt)("em",{parentName:"p"},"str")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"implementation"),": ",(0,i.kt)("em",{parentName:"p"},"str")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"initial_connection_timeout"),": ",(0,i.kt)("em",{parentName:"p"},"float")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"response_timeout"),": ",(0,i.kt)("em",{parentName:"p"},"float")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"optional"),": ",(0,i.kt)("em",{parentName:"p"},"bool")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"default_action"),": ",(0,i.kt)("em",{parentName:"p"},"protobuf class instance")," - The type is specified in the spec file under the section ",(0,i.kt)("inlineCode",{parentName:"p"},"actor_classes:action:space")," for the specific class of the actor."),(0,i.kt)("h3",{id:"__init__self-cog_settings-class_name-kwargs"},(0,i.kt)("inlineCode",{parentName:"h3"},"__init__(self, cog_settings, class_name, **kwargs)")),(0,i.kt)("p",null,"Parameter:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cog_settings"),": ",(0,i.kt)("em",{parentName:"li"},"module")," - Settings module associated with trials that will be run (",(0,i.kt)("a",{parentName:"li",href:"#cog_settings.py"},"cog_settings")," namespace)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"class_name"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - The name of the actor class for the actor. This is specific to a type of trial and must match values in the spec file under section ",(0,i.kt)("inlineCode",{parentName:"li"},"actor_classes:name"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"**kwargs"),": Accepts any of the attributes (except ",(0,i.kt)("inlineCode",{parentName:"li"},"class_name"),") as keyword to set their value on construction. E.g. ",(0,i.kt)("inlineCode",{parentName:"li"},'ActorParameters(settings, class_name="some_class", name="act_name")'))),(0,i.kt)("h2",{id:"class-cogmentlogsample"},"class cogment.LogSample"),(0,i.kt)("p",null,"Class containing a datalog sample.\nA sample starts and ends with the arrival of new observations from the environment. The last sample will end after all components have acknowledged the end of the trial (the state of that sample will then be ",(0,i.kt)("inlineCode",{parentName:"p"},"TrialState.ENDED"),")."),(0,i.kt)("p",null,"Note that some of the data may not be available (",(0,i.kt)("inlineCode",{parentName:"p"},"None"),") if it was excluded from the sample (see datalog parameters ",(0,i.kt)("inlineCode",{parentName:"p"},"TrialParameters.datalog_exclude_fields"),")."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"out_of_sync"),": ",(0,i.kt)("em",{parentName:"p"},"bool")," - False if it is a normal/full sample. True if it is an out-of-sync/partial sample. Out-of-sync samples do not follow the normal time step progression of the trial, they represent isolated data (typically a reward) for steps that have already past. Out-of-sync samples will be produced according to the trial parameter ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/parameters#nb_buffered_ticks"},"nb_buffered_ticks"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tick_id"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - The time step that the sample data relates to."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"state"),": ",(0,i.kt)("em",{parentName:"p"},"cogment.TrialState")," - The state of the trial at the end of the sample period. Undefined for out-of-sync samples."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"timestamp"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - Unix style Epoch timestamp in nanoseconds (time since 00:00:00 UTC Jan 1, 1970) at the beginning of the sample period. For out-of-sync samples, this is the time the data in the sample was received."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"events"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Description of special events that happened during the time frame of the sample. For out-of-sync samples, it may contain an explanation of the data."),(0,i.kt)("h3",{id:"__init__self-params"},(0,i.kt)("inlineCode",{parentName:"h3"},"__init__(self, params)")),(0,i.kt)("p",null,"Parameter:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"params"),": ",(0,i.kt)("em",{parentName:"li"},"LogParams instance")," - The parameters of the trial.")),(0,i.kt)("h3",{id:"get_serialization_typeself-1"},(0,i.kt)("inlineCode",{parentName:"h3"},"get_serialization_type(self)")),(0,i.kt)("p",null,"Returns the type of serial data produced by ",(0,i.kt)("inlineCode",{parentName:"p"},"serialize")," and accepted by ",(0,i.kt)("inlineCode",{parentName:"p"},"deserialize"),". The type represents an ID dependent on ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/grpc#logexportersamplerequest"},"DatalogSample")," defined in the low level gRPC API."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"int")," - The type of the serialization string data. This is the type of string that is returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"serialize"),", and the only type accepted by ",(0,i.kt)("inlineCode",{parentName:"p"},"deserialize"),"; it is undefined behavior to try to deserialize the wrong type of data. This value is strictly larger than 1."),(0,i.kt)("h3",{id:"serializeself-1"},(0,i.kt)("inlineCode",{parentName:"h3"},"serialize(self)")),(0,i.kt)("p",null,"Returns a binary string equivalent of the sample."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"str")," - Serialized sample."),(0,i.kt)("h3",{id:"deserializeself-raw_string"},(0,i.kt)("inlineCode",{parentName:"h3"},"deserialize(self, raw_string)")),(0,i.kt)("p",null,"Takes a serialized sample string and sets the LogSample instance."),(0,i.kt)("p",null,"Parameter:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"raw_string"),": ",(0,i.kt)("em",{parentName:"li"},"str")," - Binary string representing a serialized LogSample of the same type.")),(0,i.kt)("h3",{id:"all_actor_namesself"},(0,i.kt)("inlineCode",{parentName:"h3"},"all_actor_names(self)")),(0,i.kt)("p",null,"Generator method to iterate over all actors in the trial. This information can also be retrieved from the parameters of the trial."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(str)")," - A generator for the names of the actors in the trial."),(0,i.kt)("h3",{id:"get_actionself-actor"},(0,i.kt)("inlineCode",{parentName:"h3"},"get_action(self, actor)")),(0,i.kt)("p",null,"Retrieves the action from the actor in the sample."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"actor"),": ",(0,i.kt)("em",{parentName:"li"},"str")," or ",(0,i.kt)("em",{parentName:"li"},"int")," - The name or index of the actor for which to retrieve the action. The number, index and name of actors can be retrieved from the parameters of the trial.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"RecvAction instance")," - The action of the actor in the sample."),(0,i.kt)("h3",{id:"get_observationself-actor"},(0,i.kt)("inlineCode",{parentName:"h3"},"get_observation(self, actor)")),(0,i.kt)("p",null,"Retrieve the observation destined for the actor in the sample. Can be ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," (specifically for out-of-sync samples)."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"actor"),": ",(0,i.kt)("em",{parentName:"li"},"str")," or ",(0,i.kt)("em",{parentName:"li"},"int")," - The name or index of the actor for which to retrieve the observation. The number, index and name of actors can be retrieved from the parameters of the trial.")),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"RecvObservation instance")," - The observation of the actor in the sample. Can be ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," (specifically for out-of-sync samples)."),(0,i.kt)("h3",{id:"all_rewardsself"},(0,i.kt)("inlineCode",{parentName:"h3"},"all_rewards(self)")),(0,i.kt)("p",null,"Generator method to iterate over all the rewards in the sample."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(RecvReward instance)")," - A generator for the rewards in the sample."),(0,i.kt)("h3",{id:"all_messagesself"},(0,i.kt)("inlineCode",{parentName:"h3"},"all_messages(self)")),(0,i.kt)("p",null,"Generator method to iterate over all the messages in the sample."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(RecvMessage instance)")," - A generator for the messages in the sample."),(0,i.kt)("h2",{id:"class-modelinfo"},"class ModelInfo"),(0,i.kt)("p",null,"Class containing information about a model name stored in the ModelRegistry."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - The model name."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"properties"),": ",(0,i.kt)("em",{parentName:"p"},"dict{str:str}")," - Custom information associated with the model name (not specific to any iteration)."),(0,i.kt)("h2",{id:"class-modeliterationinfo"},"class ModelIterationInfo"),(0,i.kt)("p",null,"Class containing information specific to a model iteration stored in the Model Registry."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"model_name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - The name of the model."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"iteration"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - The iteration number."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"timestamp"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - When the iteration was stored in the Model Registry. Unix epoch time in nanoseconds."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"hash"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - SHA 256 hash (encoded in base64 with standard 64 characters with padding) of the iteration's data."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"size"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - Size (in bytes) of the iteration's data."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"stored"),": ",(0,i.kt)("em",{parentName:"p"},"bool")," - Whether the model is stored, as opposed to just being published (and therefore transient)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"properties"),": ",(0,i.kt)("em",{parentName:"p"},"dict{str:str}")," - Custom information associated with the iteration."),(0,i.kt)("h2",{id:"class-latestmodel"},"class LatestModel"),(0,i.kt)("p",null,"Class making the latest model iteration, from the Model Registry, available on-demand."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - The name of the model."),(0,i.kt)("h3",{id:"async-getself"},(0,i.kt)("inlineCode",{parentName:"h3"},"async get(self)")),(0,i.kt)("p",null,"Method to return the latest iteration that has been downloaded in the background. This method may wait for the first iteration to be available. Once an iteration is available, this method will not be blocking."),(0,i.kt)("p",null,"Subsequent calls to this method may return different results according to the availability of new data."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"tuple(data, ModelIterationInfo instance)")," - The data can either be a ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," string or a user object depending on ",(0,i.kt)("inlineCode",{parentName:"p"},"is_deserialized()"),". The second tuple item is a ",(0,i.kt)("inlineCode",{parentName:"p"},"ModelIterationInfo")," instance containing the information of the iteration represented by the data."),(0,i.kt)("h3",{id:"is_deserializedself"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_deserialized(self)")),(0,i.kt)("p",null,"Method to check if the model iteration is deserialized automatically."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"bool")," - True if the model is deserialized automatically in the background, in which case the data (returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"get"),") is a user object. This user object is derived by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"deserialize_func")," (parameter of ",(0,i.kt)("inlineCode",{parentName:"p"},"ModelRegistry.track_latest_model"),") with the raw bytes from the Model Registry. False if the data (returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"get"),") is the raw bytes retrieved from the Model Registry."),(0,i.kt)("h3",{id:"is_availableself"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_available(self)")),(0,i.kt)("p",null,"Method to check if an iteration is available."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Returns: ",(0,i.kt)("em",{parentName:"p"},"bool")," - True if an iteration is available, an thus ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," will not block. False otherwise."),(0,i.kt)("h3",{id:"async-wait_for_availableself"},(0,i.kt)("inlineCode",{parentName:"h3"},"async wait_for_available(self)")),(0,i.kt)("p",null,"Method to wait for an iteration to be available."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Returns: None"),(0,i.kt)("h3",{id:"async-wait_for_newerself-iteration"},(0,i.kt)("inlineCode",{parentName:"h3"},"async wait_for_newer(self, iteration)")),(0,i.kt)("p",null,"Method to wait for a newer iteration to be available.\nOnce this method returns, the newer iteration can be retrieved with ",(0,i.kt)("inlineCode",{parentName:"p"},"get"),"."),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"iteration"),": ",(0,i.kt)("em",{parentName:"li"},"int")," - Strict lower bound for awaited model iteration. I.e. the method will wait for a model iteration that is newer, and not equal, to this.")),(0,i.kt)("p",null,"Returns: None"),(0,i.kt)("h2",{id:"class-cogmentdatastorefieldsenumenum"},"class cogment.DatastoreFields(enum.Enum)"),(0,i.kt)("p",null,"Enum representing the various data in a ",(0,i.kt)("inlineCode",{parentName:"p"},"DatastoreActorData")," instance"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"UNKNOWN: Should not be used."),(0,i.kt)("li",{parentName:"ul"},"OBSERVATION: The observation."),(0,i.kt)("li",{parentName:"ul"},"ACTION: The action."),(0,i.kt)("li",{parentName:"ul"},"REWARD: The aggregated reward."),(0,i.kt)("li",{parentName:"ul"},"RECEIVED_REWARDS: All the individual rewards received by the actor (",(0,i.kt)("inlineCode",{parentName:"li"},"all_received_rewards")," method)"),(0,i.kt)("li",{parentName:"ul"},"SENT_REWARDS: All the individual rewards sent by the actor (",(0,i.kt)("inlineCode",{parentName:"li"},"all_sent_rewards")," method)"),(0,i.kt)("li",{parentName:"ul"},"RECEIVED_MESSAGES: All the messages received by the actor (",(0,i.kt)("inlineCode",{parentName:"li"},"all_received_messages")," method)"),(0,i.kt)("li",{parentName:"ul"},"SENT_MESSAGES: All the messages sent by the actor (",(0,i.kt)("inlineCode",{parentName:"li"},"all_received_messages")," method)")),(0,i.kt)("h2",{id:"class-datastoretrialinfo"},"class DatastoreTrialInfo"),(0,i.kt)("p",null,"Class containing the information of a trial stored in the Datastore."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"trial_id"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - The trial id for this trial."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"user_id"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - The user ID for the trial (provided on trial start)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"trial_state"),": ",(0,i.kt)("em",{parentName:"p"},"cogment.TrialState instance")," - The last (or current) state of the trial. This will change over time if not ",(0,i.kt)("inlineCode",{parentName:"p"},"TrialState.ENDED"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"sample_count"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - The number of samples currently stored for this trial. This will change over time if the trial state is not ",(0,i.kt)("inlineCode",{parentName:"p"},"TrialState.ENDED"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"parameters"),": ",(0,i.kt)("em",{parentName:"p"},"cogment.TrialParameters instance")," - The parameters for the trial."),(0,i.kt)("h2",{id:"class-datastoresample"},"class DatastoreSample"),(0,i.kt)("p",null,"Class containing the data of a trial sample (typically representing all the data during a trial tick)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"trial_id"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - The id of the trial the data in the sample relates to."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"trial_state"),": ",(0,i.kt)("em",{parentName:"p"},"cogment.TrialState instance")," - The state of the trial at the end of the sample period."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tick_id"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - The step/tick at which the data in the sample was obtained."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"timestamp"),": ",(0,i.kt)("em",{parentName:"p"},"int")," - Unix style Epoch timestamp of the start of the step/tick (in nanoseconds since 00:00:00 UTC Jan 1, 1970)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"actors_data"),": ",(0,i.kt)("em",{parentName:"p"},"dict{str:DatastoreActorData instance}")," - Dictionary of all actors data included in the sample, indexed by actor name."),(0,i.kt)("h2",{id:"class-datastoreactordata"},"class DatastoreActorData"),(0,i.kt)("p",null,"Class containing the data related to an actor in a sample."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"name"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the actor."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"observation"),": ",(0,i.kt)("em",{parentName:"p"},"protobuf class instance")," - Observation received by the actor. The class of the observation is defined as observation space for the actor class. This is specified in section ",(0,i.kt)("inlineCode",{parentName:"p"},"actor_classes:observation:space")," in the spec file for the appropriate actor class."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"action"),": ",(0,i.kt)("em",{parentName:"p"},"protobuf class instance")," - Action from the actor. The class of the action is defined as action space for the specific actor in the section ",(0,i.kt)("inlineCode",{parentName:"p"},"actor_classes:action:space")," in the spec file for the appropriate actor class."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"reward"),": ",(0,i.kt)("em",{parentName:"p"},"float")," - The aggregated reward received by the actor in the sample."),(0,i.kt)("h3",{id:"all_received_rewardsself"},(0,i.kt)("inlineCode",{parentName:"h3"},"all_received_rewards(self)")),(0,i.kt)("p",null,"Generator method to iterate over all the individual rewards received by the actor in the sample.\nThe aggregated reward is calculated from these."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(DatastoreReward instance)")," - A generator for the individual actor rewards received."),(0,i.kt)("h3",{id:"all_sent_rewardsself"},(0,i.kt)("inlineCode",{parentName:"h3"},"all_sent_rewards(self)")),(0,i.kt)("p",null,"Generator method to iterate over all the individual rewards sent by the actor in the sample."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(DatastoreReward instance)")," - A generator for the individual actor rewards sent."),(0,i.kt)("h3",{id:"all_received_messagesself"},(0,i.kt)("inlineCode",{parentName:"h3"},"all_received_messages(self)")),(0,i.kt)("p",null,"Generator method to iterate over all the messages received by the actor in the sample."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(DatastoreMessage instance)")," - A generator for the messages received."),(0,i.kt)("h3",{id:"all_sent_messagesself"},(0,i.kt)("inlineCode",{parentName:"h3"},"all_sent_messages(self)")),(0,i.kt)("p",null,"Generator method to iterate over all the messages sent by the actor in the sample."),(0,i.kt)("p",null,"Parameters: None"),(0,i.kt)("p",null,"Return: ",(0,i.kt)("em",{parentName:"p"},"generator(DatastoreMessage instance)")," - A generator for the messages sent."),(0,i.kt)("h2",{id:"class-datastorereward"},"class DatastoreReward"),(0,i.kt)("p",null,"Class containing the data for an individual reward in the Datastore."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"value"),": ",(0,i.kt)("em",{parentName:"p"},"float")," - Value of the reward."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"confidence"),": ",(0,i.kt)("em",{parentName:"p"},"float")," - Confidence level of the reward value."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"sender"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the sender of the reward."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"receiver"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the receiver of the reward. The string could contain wildcard characters to represent multiple receivers intended by the sender."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"user_data"),": ",(0,i.kt)("em",{parentName:"p"},"google.protobuf.Any instance")," - Data for a user-specific reward format. Can be ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if no specific data was provided. The class enclosed in ",(0,i.kt)("inlineCode",{parentName:"p"},"google.protobuf.Any")," is of the type set by the sender; it is the responsibility of the receiver to manage the data received (i.e. determine the type and unpack the data)."),(0,i.kt)("h2",{id:"class-datastoremessage"},"class DatastoreMessage"),(0,i.kt)("p",null,"Class containing the data of a message in the Datastore."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"sender"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the sender of the message."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"receiver"),": ",(0,i.kt)("em",{parentName:"p"},"str")," - Name of the receiver of the message. The string could contain wildcard characters to represent multiple receivers intended by the sender."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"payload"),": ",(0,i.kt)("em",{parentName:"p"},"google.protobuf.Any instance")," - Data for a received message. The class enclosed in ",(0,i.kt)("inlineCode",{parentName:"p"},"google.protobuf.Any")," is of the type set by the sender; It is the responsibility of the receiver to manage the data received (i.e. determine the type and unpack the data)."))}m.isMDXComponent=!0}}]);